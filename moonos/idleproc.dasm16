; ------------------
; idle process
; handles I/O polling, waking up processes stalled on I/O
; ------------------
idleproc_entry:
	set x, [readch_process]		; anything listening for keyboard events?
	ife x, 0					; nope
		b 1f					; skip the keyboard test
	set a, [readch_keyptr]		; current keyboard read pointer
	ife [a], 0					; is there a character waiting?
		b 1f					; nope; skip ahead
	set y, [idleproc_table]		; get the process that would execute after us
	jsr dll_splice				; and schedule the process that was waiting before it		
	set [readch_process], 0		; it's not waiting any more
1:

	set push, idleproc_entry	; reschedule our entrypoint
	set pc, TaskSwitch			; and go taskswitch

idleproc_sp:
  dat idleproc_entry
  
idleproc_table:
  dat initproc_table    ; next
  dat initproc_table    ; prev
  dat idleproc_entry    ; block start
  dat idleproc_sp       ; sp
  dat 0					; owned screen area
