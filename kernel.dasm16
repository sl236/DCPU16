; ------------------
; public API
; ------------------
; NB. kernel functions may trash any registers except SP (this includes TaskSwitch).
; Kernel functions will not push data to process stack.
; The range [ScratchArea, KernelTables) is available for application use. 
; It is not preserved over TaskSwitch but is preserved over other kernel calls.

def Exit			0x00
def Spawn			0x01
def ScratchArea		0x14
def KernelTables	0x18
def TaskSwitch		0x1f

; ------------------
; initial setup
.org 0
	set pc, init

.org KernelTables				; private kernel tables
freelist: dat freemem_block		; freelist next pointer
proclist: dat idleproctable
          dat freemem_block		; freelist prev pointer
		  dat freelist			; freelist head block start
          		
; ------------------
; kernel implementation
; ------------------

; proctable format
def proctable_sp_offset		0
def proctable_next_offset	1
def proctable_prev_offset	2
def proctable_block_start	3
def proctable_size			(proctable_block_start+1)

; executable format
def exeheader_exesize		0	; executable area word count
def exeheader_exestart		1	; executable area first word offset
; words from here to exeheader_exestart are relocation offsets

; 0 - sp
; 1 - next process
; 2 - prev process
; 3 - start of process memory
; [sp] holds return address
; process memory ends at end of process table
; process stack begins at start of process table

; ----- TaskSwitch
; ----- Assumes return address on stack. Preserves sp, nothing else
.org TaskSwitch
taskswitch_impl:
	set a,   [proclist]	; address of current process table
	set [a], sp			; store sp
	set a,   [a+1]		; next process
	set sp,  [a]		; fetch sp
	set pc,  pop		; return

; ----- Exit
; ----- Exits current process, releasing its memory and removing it from the task list
exit_impl:
	set c, proclist		; [proclist] is current process
	set a, [c]			; a = address of current process' table
	set b, [a+2]		; previous live process
	set [c], b			; current process is now the previous process
	set [b+2], [a+1]	; remove current process from process list (previous' next is now our next)
	
	set x, freelist		; freelist start	
1:						; insert into freelist, keeping ordered
	set x, [x]			; next item
	ifg x, a			; if the next block still comes after a
		b 1b			;	loop round
	set y, [x+proctable_prev_offset]	; fetch previous item
		
	; coalesce with next block? 
	set b, [x+proctable_block_start]	; start of next block
	set c, a							; to calculate end of this block,
	add c, proctable_size				;    add block size offset to current block start
	ifn b, c							; if end of this block is not start of next block
		b 1f							; skip over the coalesce operation
	set [x+proctable_block_start], [a+proctable_block_start]	; copy this block's start to next block's table
	set a, x							; use next block's table for both blocks
	set x, [x]							; next is now next's next

1:
	set b, [a+proctable_block_start]	; start of block being freed
	set c, y
	add c, proctable_size				; end of previous block	
	ifn b, c							; if they're not equal
		b 1f							; don't coalesce
		
	set [a+proctable_block_start], [y+proctable_block_start]	; use previous block's start in our table
	set y, [y+proctable_prev_offset]							; previous block's previous is now previous

1:
	set [a], x							; x is our next
	set [a+proctable_prev_offset], y	; y is our prev
	set [y], a							; we are prev's next
	set [x+proctable_prev_offset], a	; we are next's prev
	
	; done! taskswitch to next process
	set sp,  [proclist]	; fetch sp
	set pc,  pop		; return
		
; ----- Spawn	
; ----- Allocate A words of memory for a new process. 
; ----- B points to process header; this will be used to copy and relocate the binary. A must be large enough for process.
; ----- New process will have at least A words available between start of its process space and SP
; ----- but may have more.
def align 32
spawn_impl:
	add a, (proctable_size+(align-1))	; add proctable size to memory requested by process, and enough padding for alignment
	and a, ~align						; ensure alignment
	sub a, (proctable_size-1)			; (size-proctable_size) for a block is one less instruction than size to calculate. Subtract another 1 so we can use ifg
	set x, freelist						; start from the freelist
	set z, 0xffff						; best found size

1:
	set y, x							; start of block descriptor
	sub y, [x + proctable_block_start]	; size of memory available to process
	ifg y, a
	  b 1f
	set x, [x]
	b 1b
1:
	
	sub pc, 1 ; TODO
	
	

; ------------------
; idle process
; ------------------
idleentry:
	jsr TaskSwitch
idlestack:
	dat idleentry
idleproctable:
	dat idlestack
	dat idleproctable
	dat idleproctable
	dat idleentry	

; ------------------
kernel_end:

; ------------------
; bootstrapping
; ------------------
init:
	sub pc, 1 ; TODO


; ------------------
; area between kernel_end and 0x8000 is on free list
; ------------------
.org (0x8000 - proctable_size)
freemem_block:
	dat freelist		; next
	dat 0x1234			; (unused)
	dat freelist		; prev
	dat kernel_end		; block start
