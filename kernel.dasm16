; ------------------
; public API
; ------------------
; NB. kernel functions may trash any registers except SP (this includes TaskSwitch).
; Kernel functions may push up to two words of data to process stack.

def Exit			    0x00
def Fork			    0x02
def Reserved0     0x04
def Reserved0     0x06
def Reserved0     0x08
def Reserved0     0x0A
def Reserved0     0x0C
def Reserved0     0x0E
def KernelTables	0x10
def TaskSwitch		0x1f

; ------------------
; kernel implementation
; ------------------

.org 0
  set pc, init ; exit_impl
  set pc, fork_impl
  set pc, _crash      ; 0x04
  set pc, _crash      ; 0x06
  set pc, _crash      ; 0x08
  set pc, _crash      ; 0x0A
  set pc, _crash      ; 0x0C
  set pc, _crash      ; 0x0E

; ------------------
  
.org KernelTables				        ; private kernel tables
freelist:   dat freemem     	  ; freelist next pointer
            dat freemem     	  ; freelist prev pointer
proclist:   dat initproc_table  ; current process table address
		        dat freelist			  ; freelist head block start
          		
; kernel table format
def kerntable_next    		0
def kerntable_prev      	1
def kerntable_data      	2
def kerntable_block_start	3
def kerntable_size			  (kerntable_block_start+1)

; blocks of memory are defined as [ptr+kerntable_block_start] .. (ptr+kerntable_size)
; for process tables, kerntable_data holds the stack pointer 
; and when a process is not executing, the top of its stack holds its next pc
; for free blocks, kerntable_data is unused and undefined
; a process's stack base is the start of its process table

; ----- TaskSwitch (0x1f)
; ----- Assumes return address on stack. Preserves sp, nothing else
.org TaskSwitch
taskswitch_impl:
  set b, proclist                 ; current process table address held here
	set a,   [b]	                  ; fetch it
	set [a+kerntable_data], sp			; store sp there
	set a,   [a]	                  ; get next process table
  set [b], a                      ; store it
	set sp,  [a+kerntable_data]		  ; fetch sp
	set pc,  pop		                ; resume process

; remove item at X from doubly linked list (and make it form its own valid dll with only itself on it)
; trashes A, B
dll_delete:
  set a, [x]                   ; next
  set b, [x+kerntable_prev]    ; prev
  set [a+1], b    ; prev now next's prev
  set [b], a      ; next now prev's next
  set [x], x      ; fix up curr node's next
  set [x+1], x    ; and prev
  set pc, pop     ; done

; splice dll X between Y and Y's prev (new list will go ... Y's prev, X ... X's prev, Y )   Y'<->X<-...->X'<->Y
; trashes b, returns Y's prev in a
dll_splice:
  set a, [y+1]    ; Y's prev
  set [a], x      ; Y's prev's next now X
  set b, [x+1]    ; X's prev
  set [x+1], a    ; X's prev now Y's prev
  set [b], y      ; X's prev's next now Y     
  set [y+1], b    ; Y's prev now X's prev  
  set pc, pop     ; done  

; ----- Exit
; ----- Exits current process, releasing its memory and removing it from the task list
exit_impl:
	set x, [proclist]	  ; [proclist] is current process (to be deleted)
  set z, [x]          ; next process
  set [proclist], z   ; will be current when we're done
  jsr dll_delete      ; remove from the process list
  
  set y, freelist     ; head of freelist
1:
  set y, [y]          ; next free block
  ife y, freelist     ; have we come back to the start?
    b 1f              ; then X should be last in the list; bail
  ifg x, y            ; if's still before X
    b 1b              ; keep looking
1:

  jsr dll_splice      ; insert X here
  
  ; if a+kerntable_size == x, we should coalesce them
  ; likewise if x+kerntable_size == Y, we should coalesce those

  set c, x                ; take a copy of x
  set b, a                ; copy a
  add b, kerntable_size   ; add kerntable_size
  ifn b, x                ; if it's not equal to x
    b 1f                  ; don't coalesce
  
  set [x+kerntable_block_start], [a+kerntable_block_start]  ; the new block starts where a used to
  set x, a                ; now we can remove a from the freelist
  jsr dll_delete          ; so do that
  set x, c                ; put x back for next operation
    
1:
  add c, kerntable_size   ; c still holds a copy of x
  ifn c, y                ; if that's not equal to y
    b 1f                  ; don't coalesce
  
  set [y+kerntable_block_start], [x+kerntable_block_start]  ; Y now starts where X used to
  jsr dll_delete          ; and we can remove x from the list
1:    
	
	; done! taskswitch to next process
  set a,    [proclist]    ; next process table
	set sp,   [a]	          ; fetch its sp
	set pc,   pop		        ; return there
		
; ----- Fork
; ----- Allocate X words of memory for a new process.
; ----- New process will have at least X words available between start of its process space and SP, but may have more.
; ----- Old process's stack will be copied to new process space.
; ----- Execution will resume in old process space for both processes, however the new process' SP will point to the new stack

def align 16
fork_impl:
  set A, [proclist]      ; current process' table
  sub A, SP               ; area required for current stack
  add A, (align-1)        ; align to a sensible size: pad
  and A, ~(align-1)       ; and mask
  ifg A, X                ; if the result is more than caller asked for
    set X, A              ; use that instead so we don't crash

  set A, freelist         ; freelist head

1:
  set A, [A]              ; next block
  ife A, freelist         ; if we're back at the head
    set pc, out_of_memory ; then not much we can do
  set B, A                ; grab a copy
  sub B, [A + kerntable_block_start]  ; work out how big the block is
  ifg X, B                ; if we need more memory
    b 1b                  ; go around
        
  set C, B                ; we know B>=X
  sub C, X                ; so this is always >=0
  set B, A                ; block start
  sub B, X                ; new process wants to start here    
  ifg (align+4), C        ; block too small to split?
    b 1f                  ; give the caller the whole thing
  
  set C, B                      ; new process start
  sub C, kerntable_size         ; new free block can live here
  set [C], A                                     ; block detached: its next points to the old block
  set [C+kerntable_prev], [A+kerntable_prev]     ; and its prev to the old block's prev
  set [A+kerntable_prev], C     ; the old block's prev points to the new block
  set [C+kerntable_block_start], [A+kerntable_block_start]    ; the new block starts where the old block used to
  set [A+kerntable_block_start], B                            ; and that starts where the new one ends
  
1:
  ; whatever happened, A currently holds a suitable block for the new process
  ; that block is still in the freelist right now so let's detach it
  set X, A            ; copy block start to X
  jsr dll_delete      ; remove it from the freelist
  
  ; now we need to copy the stack over  
  set Z, SP           ; copy SP somewhere safe
  set A, [proclist]   ; stack starts at the process table
  sub A, SP           ; and ends at SP, so get its size
  set B, X            ; new stack starts at the new process table
  sub B, A            ; and ends the same distance away as the old
  set [X+kerntable_data], B ; store that in the new process table while we have it
  
1:
  set [B], [SP++]     ; copy over next word
  add B, 1            ; move on
  ifn B, X            ; if we've not hit the process table
    b 1b              ; go around
  
  set SP, Z           ; restore our stack pointer  
  set Y, [proclist]   ; current process table address
  jsr dll_splice      ; add the new process to the process list
  set pc, pop         ; we're done

; ------------------
; utility functions
; ------------------

; places hex representation of A into four words starting at B
; leaves C and Z trashed, A zeroed
format_hex: 
  set z, sp       ; stash a copy of the stack pointer
  set sp, b       ; we'll use it to generate the string
  add sp, 4       ; start at the least significant digit
 
1: 
  set C, A
  and C, 0xF
  add C, '0'
  ifg C, '9'
    add C, (('A' - '9')-1)
  set [--sp], C
  shr a, 4
  ifn sp, b
    b 1b
  
  set sp, z
  set pc, pop

;  copies null-terminated string at A to B, orring C with each character. Trashes X.
strcpy:
1:
  set X, [A]
  ife X, 0
    set pc, pop
    
  bor X, C
  set [B], X
  add A, 1
  add B, 1
  b 1b

; ------------------
; crash handlers
; ------------------

out_of_memory:
    set A, oom_message
    set B, 0x8000
    set C, 0xC000
    set push, _crash_terminate
    set pc, strcpy
_crash:
    set B, 0x8000
    set C, 0xC000
_crash_terminate:
    set A, crash_message
    jsr strcpy    
    set push Exit
    set pc, strcpy

oom_message: "Out of memory.", 0
crash_message: dat "Process terminated:", 0, 0, 0, 0, 0
  		
; ------------------
; idle process
; ------------------
idleproc_entry:
	set push, idleproc_entry
  set pc, TaskSwitch

idleproc_sp:
  dat idleproc_entry
  
idleproc_table:
  dat initproc_table    ; next
  dat initproc_table    ; prev
  dat idleproc_sp       ; sp
  dat idleproc_entry    ; block start

; ------------------
; boot process
; ------------------

init_start:
  .org init_start + 0x20      ; reserve some memory

init:
  set sp, initproc_table      ; at boot, the stack pointer was not set up for us
  set X, 0x100                ; ask for a small amount of memory for the new process
  jsr Fork                    ; fork
  
  set A, message
  set B, hw_vram
  set C, 0xC000
  ife sp, initproc_table      ; original process?
    b 1f
    
  add B, 32                   ; second process writes a line down
  set C, 0x2000               ; uses a different colour
  set A, message2             ; and has a different message

1:
  set i, b                    ; both processes share this code
  add i, 16                   ; subsequent writes will be halfway across the screen  
  set push, i                 ; store that on the stack
  set push, c                 ; also the colour

  set j, [proclist]           ; process table address
  set j, [j+kerntable_block_start]  ; current process' memory
  set [j+5], 0                ; we'll be writing four character strings there, and want them null-terminated
  set push, j                 ; store that to avoid recalculating
  set push, 0                 ; and make a counter as well
  
  jsr strcpy                  ; display the static message
  
1:  
  jsr TaskSwitch              ; taskswitch
  set i, sp                   ; copy the stack pointer so we can use register indirect addressing
  set a, [i]                  ; fetch the counter
  add a, 1                    ; increment it
  set [i], a                  ; store it back
  set b, [i+1]                ; this process's local buffer
  jsr format_hex
  set a, [i+1]
  set b, [i+3]
  set c, [i+2]
  jsr strcpy
  
  b 1b
    

message:
  dat "Hello world!", 0
message2:
  dat "Process 2", 0

  dat 0, 0, 0, 0, 0, 0, 0, 0 ; some stack space
  dat 0, 0, 0, 0, 0, 0, 0, 0 ; some more
initproc_table:
  dat idleproc_table    ; next
  dat idleproc_table    ; prev
  dat initproc_table    ; no stack
  dat init_start        ; block start
  
; ------------------
kernel_end:
; ------------------

; ------------------
; Memory-mapped HW
; ------------------

def hw_vram      0x8000
def hw_chars     0x8180
def hw_vram_end  0x8200

def hw_keyboard       0x9000
def hw_keyboard_end   0x9010

def hw_end  0xA000


; ------------------
; freelist
; ------------------
; area between kernel_end and 0x8000 is available
.org (0x8000 - kerntable_size)
freemem:
	dat freelist    	; next
	dat freelist		  ; prev
	dat 0x1234			  ; (unused)
	dat kernel_end		; block start
 
; NB. Notch's emulator loads 0x10000 *chars*, 
; so we have no way of specifying memory content beyond 0x8000 statically
