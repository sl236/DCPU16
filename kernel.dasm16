; ------------------
; public API
; ------------------
; NB. TaskSwitch may trash any registers except SP.
; Kernel functions and interrupts may push up to eight words of data to process stack.

def Exit			    0x00	; exit current process
def Fork			    0x02	; spawn a new process
def ReadChar		    0x04	; line input to be written in terms of this, its code held in the process that uses it
;
def TaskSwitch			0x1f

; ------------------
; kernel implementation
; ------------------

macro RESERVE_WORDS(_x)
  999: .org (999b+_x)
endm

.org 0
  set pc, init					  ; 0x00 exit_impl		
  set pc, fork_impl				; 0x02
  set pc, readch_impl			; 0x04

; reserved area

.org 0x1e
	proclist: dat initproc_table	    ; current process table address

; ----- TaskSwitch (0x1f)
; ----- Assumes return address on stack. Preserves sp, nothing else
.org TaskSwitch
taskswitch_impl:
	set b,	 proclist					; current process table address held here
	set a,   [b]						; fetch it
	iaq 1								; critical section
	set [a+kerntable_saved_sp], sp			; store sp there
	set a,   [a]							; get next process table
	set [b], a								; store it
	set sp,  [a+kerntable_saved_sp]			; fetch sp
	iaq 0								; end critical section
	set pc,  pop		                ; resume process
        		
; ----- kernel table format
def kerntable_next    		0
def kerntable_prev      	1
def kerntable_block_start	2
def kerntable_saved_sp     	3
def kerntable_size			(kerntable_saved_sp+1)

; ----- Exit
; ----- Exits current process, releasing its memory and removing it from the task list
exit_impl:
  iaq 1				  ; critical section
  set x, [proclist]		; [proclist] is current process (to be deleted)
  set z, [x]			; next process
  set [proclist], z		; will be current when we're done
  jsr dll_delete		; remove from the process list
  iaq 0				  ; end critical section
  
  jsr free			  ; release process memory
	
	; done! taskswitch to next process
  set a,    [proclist]					; next process table
  set sp,   [a + kerntable_saved_sp]	; fetch its sp
  set pc,   pop						; return there

; ----- malloc
; ----- allocate X words of memory; returns block table ptr in X
def align 16
malloc:
  set push, a
  set push, b
  set push, c
  set push, z
  set A, freelist         ; freelist head

1:
  set A, [A]              ; next block
  ife A, freelist         ; if we're back at the head
    set pc, out_of_memory ; then not much we can do
  set B, A                ; grab a copy
  sub B, [A + kerntable_block_start]  ; work out how big the block is
  ifg X, B                ; if we need more memory
    b 1b                  ; go around
        
  set C, B                ; we know B>=X
  sub C, X                ; so this is always >=0
  set B, A                ; block start
  sub B, X                ; new process wants to start here    
  ifg (align+4), C        ; block too small to split?
    b 1f                  ; give the caller the whole thing
  
  set C, B                      ; new block start
  sub C, kerntable_size         ; new free block can live here
  set [C], A													; block detached: its next points to the old block
  set Z, [A+kerntable_prev]										; (fetch old block's prev)
  set [C+kerntable_prev], Z										; and its prev to the old block's prev
  set [A+kerntable_prev], C										; the old block's prev points to the new block
  set [Z], C													; as does the old block's prev's next
  set [C+kerntable_block_start], [A+kerntable_block_start]		; the new block starts where the old block used to
  set [A+kerntable_block_start], B								; and that starts where the new one ends
  
1:
  ; whatever happened, A currently holds a suitable block
  ; that block is still in the freelist right now so let's detach it
  set X, A            ; copy block start to X
  jsr dll_delete      ; remove it from the freelist
  set z, pop
  set c, pop
  set b, pop
  set a, pop
  set pc, pop		  ; return

; ----- Free
; ----- Release memory described by X back to the system. X is trashed.
free:
  set push, a
  set push, b
  set push, c
  set push, y
  
  set y, freelist     ; head of freelist
1:
  set y, [y]          ; next free block
  ife y, freelist     ; have we come back to the start?
    b 1f              ; then X should be last in the list; bail
  ifg x, y            ; if's still before X
    b 1b              ; keep looking
1:

  jsr dll_splice      ; insert X here
  
  ; if a+kerntable_size == x, we should coalesce them
  ; likewise if x+kerntable_size == Y, we should coalesce those

  set c, x                ; take a copy of x
  set b, a                ; copy a
  add b, kerntable_size   ; add kerntable_size
  ifn b, x                ; if it's not equal to x
    b 1f                  ; don't coalesce
  
  set [x+kerntable_block_start], [a+kerntable_block_start]  ; the new block starts where a used to
  set x, a                ; now we can remove a from the freelist
  jsr dll_delete          ; so do that
  set x, c                ; put x back for next operation
    
1:
  add c, kerntable_size   ; c still holds a copy of x
  ifn c, y                ; if that's not equal to y
    b 1f                  ; don't coalesce
  
  set [y+kerntable_block_start], [x+kerntable_block_start]  ; Y now starts where X used to
  jsr dll_delete          ; and we can remove x from the list
1:    

  set y, pop
  set c, pop
  set b, pop
  set a, pop
  set pc, pop


; ----- Fork
; ----- Allocate X words of memory for a new process.
; ----- New process will have at least X words available between start of its process space and SP, but may have more.
; ----- Old process's stack will be copied to new process space.
; ----- Execution will resume in old process space for both processes, however the new process' SP will point to the new stack

def align 16
fork_impl:
  set A, [proclist]       ; current process' table
  sub A, SP               ; area required for current stack
  add A, 8				  ; ensure space for ISRs and kernel calls
  add A, (align-1)        ; align to a sensible size: pad
  and A, ~(align-1)       ; and mask
  ifg A, X                ; if the result is more than caller asked for
    set X, A              ; use that instead so we don't crash

  jsr malloc			  ; allocate process memory
  
  ; now we need to copy the stack over  
  set I, [proclist]   ; stack starts at the process table
  set J, X            ; new stack starts at the new process table
  
1:
  std [J], [I]		  ; copy and decrement
  ifn I, SP           ; if we've not copied the whole stack
    b 1b              ; go around
  set [J], [I]		  ; copy last word

  set [X+kerntable_saved_sp], J ; store new process SP
  
  set Y, [proclist]   ; current process table address
  iaq 1				  ; critical section
  jsr dll_splice		; add the new process to the process list
  iaq 0				  ; end critical section
  set pc, pop         ; we're done

; ------------------
; internal utility functions, subject to change
; ------------------

; ----- format_hex
; places hex representation of A into four words starting at B, ORing with C
format_hex:
  set push, a 
  set push, x

  set x, a
  and x, 0xF
  set x, [x+format_hex_data]
  bor x, c
  set [b+3], x
  shr a, 4
  set x, a
  and x, 0xF
  set x, [x+format_hex_data]
  bor x, c
  set [b+2], x
  shr a, 4
  set x, a
  and x, 0xF
  set x, [x+format_hex_data]
  bor x, c
  set [b+1], x
  shr a, 4
  set a, [a+format_hex_data]
  bor a, c
  set [b], a
  
  set x, pop  
  set a, pop  
  set pc, pop
  
format_hex_data: dat "0123456789ABCDEF"

; ----- strcpy  
;  copies null-terminated string at I to J, orring C with each character. I, J point to end of string on exit. Terminating null is not copied. A is zeroed.
strcpy:
  set a, [I]    
  ife a, 0
    set pc, pop
  bor a, C
  sti [J], a
  b strcpy
 
; ----- dll_delete
; remove item at X from doubly linked list (and make it form its own valid dll with only itself on it)
; trashes A, B
dll_delete:
  set a, [x]                   ; next
  set b, [x+kerntable_prev]    ; prev
  set [a+kerntable_prev], b    ; prev now next's prev
  set [b], a				   ; next now prev's next
  set [x], x				   ; fix up curr node's next
  set [x+kerntable_prev], x    ; and prev
  set pc, pop				   ; done

; ----- dll_splice
; splice dll X between Y and Y's prev (new list will go ... Y's prev, X ... X's prev, Y )   Y'<->X<-...->X'<->Y
; trashes b, returns Y's prev in a
dll_splice:
  set a, [y+kerntable_prev]		; Y's prev
  set [a], x					; Y's prev's next now X
  set b, [x+kerntable_prev]		; X's prev
  set [x+kerntable_prev], a		; X's prev now Y's prev
  set [b], y					; X's prev's next now Y     
  set [y+kerntable_prev], b		; Y's prev now X's prev  
  set pc, pop					; done  

; ------------------
; interrupt handlers
; ------------------

def isr_header_magic 0x3457
isr_entry:
	bor a, 0
	ifn [a-1], isr_header_magic		; sanity check: does the message hold the address of an ISR?
	    rfi 0						; nope. Ignore it
	set pc, a						; branch to handler

dat isr_header_magic	; ---- keyboard handler	
isr_handle_keyboard:
	ife [keyboard_wait_proc], 0	; process waiting on keyboard?
		rfi 0					; nope. Bail.
	set push, x					; can't trash registers of whatever we interrupted, store them
	set push, y					
	set push, b
	set x, [keyboard_wait_proc]	; fetch waiting process
	set [keyboard_wait_proc], 0 ; it's not waiting any more
	set y, [proclist]			; active process
	jsr dll_splice				; add the process that was waiting just before it
	set b, pop					; restore registers
	set y, pop
	set x, pop
	rfi 0						; exit ISR
keyboard_wait_proc:
	dat 0

dat isr_header_magic	; ---- clock tick handler	
isr_handle_clock:
	set push, ex
	add [clock_time], 1
	add [clock_time+1], ex
	set ex, pop
	rfi 0
	
; ------------------
; crash handlers
; ------------------

out_of_memory:
    set i, oom_message
    set j, [screen_vram]
    set c, 0xC000
    set push, _crash_terminate
    set pc, strcpy
_crash:
    set j, [screen_vram]
    set c, 0xC000
_crash_terminate:
    set i, crash_message
    jsr strcpy    
    set push Exit
    set pc, strcpy

oom_message: "Out of memory.", 0
crash_message: dat "Process terminated:", 0, 0, 0, 0, 0

; ------------------
; kernel internal data structures
; ------------------
freelist:		dat freemem_first		; freelist next pointer
				dat freemem_last		; freelist prev pointer
				dat freelist			; freelist head block start

screen_device_id:		dat 0xffff
screen_vram:			dat 0
screen_charmap:			dat 0
screen_palette:			dat 0
screen_block_handle:	dat 0

keyboard_device_id:	dat 0xffff

clock_device_id:	dat 0xffff
clock_time:			dat 0, 0

; ------------------
; ReadChar
; If B is nonzero, blocks until a key is typed; otherwise, returns immediately.
; Returns key code in C, or 0 if none available.
; Blocking form will trash all registers.
; ------------------
readch_impl:
    set push, A
    set push, B

readch_reentry:    
    set A, 1
	set C, 0		
	ifn [keyboard_device_id], 0xffff
		hwi [keyboard_device_id]
	set B, pop
	set A, pop
	ife B, 0
	    set pc, pop	    
	ifn C, 0
	    set pc, pop
	    
    set push, A
    set push, B
	ifn [keyboard_wait_proc], 0
		b 1f		
	
	iaq 1
	set x, [proclist]
	set [proclist], [x]
	set [keyboard_wait_proc], x
	jsr dll_delete
	set push, readch_reentry
	set [x+kerntable_saved_sp], sp
	set x, [proclist]
	set sp, [x+kerntable_saved_sp]
	iaq 0
	set pc, pop
	
1:
	jsr TaskSwitch
	set pc, readch_reentry
		
; ------------------
; idle process
; ------------------
idleproc_entry:
	ife [screen_vram], 0
		b 1f
	
	set A, [clock_time+1]
	set B, idleproc_statusline
	set C, 0
	jsr format_hex
	set A, [clock_time]
	add B, 5
	jsr format_hex
	set I, idleproc_statusline
	set J, [screen_vram]
	add J, 32*11
	set C, 0x2000
	jsr strcpy
	
1:
	set push, idleproc_entry	; reschedule our entrypoint
	set pc, TaskSwitch			; and go taskswitch	
	
idleproc_statusline:
	;	 0123456789ABCDEF0123456789ABCDEF
	dat	"0123:4567 ----------------------", 0
		
	RESERVE_WORDS( 0x20 )	; stack space
	
idleproc_sp:
	dat idleproc_entry
  
idleproc_table:
	dat initproc_table		; next
	dat initproc_table		; prev
	dat idleproc_entry		; block start
	dat idleproc_sp			  ; sp
.org idleproc_table + kerntable_size

; ------------------
; shell
; ------------------
shellproc_start:

def SCREEN_ROWS     12
def SCREEN_COLUMNS  32
def SHELL_ROWS      6
def SHELL_COLOUR    0x2000

; ---- data area

shellproc_line_buffer_memory:
  RESERVE_WORDS( SCREEN_COLUMNS )
shellproc_line_buffer_memory_end:

shellproc_line_cursor:
  dat 0
shellproc_line_end:
  dat 0

shellproc_line_vram_start:
  dat 0  
shellproc_line_vram_curr:
  dat 0


; ---- entrypoint
shellproc_entry:
	set i, [shellproc_line_vram_start]  ; VRAM start
  set j, i
  add j, SCREEN_COLUMNS               ; next row down
  set x, i
  add x, (SCREEN_COLUMNS * (SHELL_ROWS-1))  ; end of scroll area

1:
  sti [i], [j]  ; copy to row above
  ifn i, x      ; end of area?
    b 1b        ; no, go around
  
  set [shellproc_line_vram_curr], i   ; line entry will be here
  set i, x                            ; need to clear the line
  add x, SHELL_ROWS
1:
  sti [i], 0
  ifn i, x
    b 1b
  
  set [shellproc_line_cursor], shellproc_line_buffer_memory
  set [shellproc_line_end], shellproc_line_buffer_memory+1
  set [shellproc_line_buffer_memory], 0

shellproc_readline_loop:
	set B, 1              ; use blocking form
	jsr ReadChar          ; fetch next char
  
  ifl C, 0x1e                 ; editing char?
    set pc, shellproc_handle_edit   ; handle that
  ifg C, 0x7f                 ; arrow or control?
	  set pc, shellproc_handle_arrow  ; handle that

  ; insert regular character
  set i, [shellproc_line_end]               ; current end of line
  ife i, shellproc_line_buffer_memory_end   ; out of memory?
    b shellproc_readline_loop               ; drop the keypress

  set x, [shellproc_line_cursor]            ; current cursor pos
  set j, i                                  ; line end
  add i, 1                                  ; we're adding a character
1:
  std [i], [j]                              ; shuffle characters up
  ifn j, x                                  ; at cursor position?
    b 1b                                    ; no, keep shuffling

  set [x], c                                ; new character goes here  
  add [shellproc_line_cursor], 1            ; cursor moves on one character
  add [shellproc_line_end], 1               ; as does end of line

shellproc_update_screen:
  jsr TaskSwitch

  set i, [shellproc_line_vram_curr]
  set x, i
  add x, SCREEN_COLUMNS
1:
  sti [i], 0
  ifn i, x
    b 1b
  set i, shellproc_line_buffer_memory       ; update display: from buffer memory
  set j, [shellproc_line_vram_curr]         ; to VRAM
  set c, SHELL_COLOUR                       ; using the shell colour
  jsr strcpy                                ; and copy
  
  set a, [shellproc_line_vram_curr]
  add a, [shellproc_line_cursor]
  sub a, shellproc_line_buffer_memory
  bor [a], 0x0200
  
  set pc, shellproc_readline_loop           ; next character
  
  
  
shellproc_handle_edit:
  ifl c, 0x10
    set pc, shellproc_readline_loop
  ifg c, 0x13
    set pc, shellproc_readline_loop
  set pc, [c + shellproc_edit_handlers - 0x10];
shellproc_edit_handlers:
    dat shellproc_handle_backspace
    dat shellproc_handle_return
    dat shellproc_handle_insert
    dat shellproc_handle_delete

shellproc_handle_backspace:
    set x, [shellproc_line_end]
    ife x, (shellproc_line_buffer_memory+1)
        set pc, shellproc_readline_loop
    set i, [shellproc_line_cursor]
    set j, i
    add j, 1
1:
    sti [i], [j]
    ifn i, x
        b 1b
    set [i], 0
    sub [shellproc_line_cursor], 1
    sub [shellproc_line_end], 1
    set pc, shellproc_update_screen
    
shellproc_handle_return:
    set pc, shellproc_entry ; todo
        
shellproc_handle_insert:    
    set pc, shellproc_readline_loop ; todo
    
shellproc_handle_delete:    
    set pc, shellproc_readline_loop ; todo
  
shellproc_handle_arrow:
  set pc, shellproc_readline_loop ; todo
  	
	
	RESERVE_WORDS( 0x20 )	; stack space
shellproc_sp:
	dat shellproc_entry
  		
shellproc_table:
	dat shellproc_table		; next
	dat shellproc_table		; prev
	dat shellproc_start		; block start
	dat shellproc_sp		  ; sp
.org shellproc_table + kerntable_size

; ------------------
; boot process
; ------------------
init_start:  
init:  
  set [1], exit_impl			; the jump at location 0 needs to go to the Exit implementation
  set sp, initproc_table	; at boot, the stack pointer was not set up for us
  ias isr_entry					  ; can now handle interrupts
  
	; -- Device enumeration
  set i, 0						; running device count
  hwn j							; total number of devices
   
init_hw:
	ife i, j					; enumerated everything?
		set pc, init_hw_end		; bail
	
	hwq i						; fetch device params into a+b, c, x+y
	
	; LEM1802 Low Energy Monitor - http://dcpu.com/highnerd/rc_1/lem1802.txt
	ife b, 0x7349
	ife a, 0xf615
		set pc, init_hw_lem1802

	; Generic Keyboard (compatible) - http://dcpu.com/highnerd/rc_1/keyboard.txt
	ife b, 0x30cf
	ife a, 0x7406
		set pc, init_hw_generic_keyboard

	; Generic Clock (compatible) - http://dcpu.com/highnerd/rc_1/clock.txt
	ife b, 0x12d0
	ife a, 0xb402
		set pc, init_hw_generic_clock

init_hw_next:
	add i, 1							; next device ID
	set pc, init_hw						; go around

init_hw_lem1802:
	ifn [screen_device_id], 0xffff		; already got one?
		set pc, init_hw_next			; can only deal with one right now
	set [screen_device_id], i			; store the device ID
	
	set X, 0x180 + 0x100 + 0x10			; vram, charmap, palette
	jsr malloc							; allocate memory for these
	set [screen_block_handle], X		; store the block handle
	set b, [X+kerntable_block_start]	; start of allocated area
	set [screen_vram], b				; that's the VRAM
	set a, 0							; MEM_MAP_SCREEN
	hwi i								; map it
	add b, 0x180						; after the VRAM, the charmap
	set [screen_charmap], b				; store it
	set a, 4							; MEM_DUMP_FONT
	hwi i								; populate it with defaults
	set a, 1							; MEM_MAP_FONT
	hwi i								; map it
	add b, 0x100						; after the charmap, the palette ram
	set [screen_palette], b				; store it
	set a, 5							; MEM_DUMP_PALETTE
	hwi i								; populate it with defaults	
	set a, 2							; MEM_MAP_PALETTE
	hwi i								; map it
	set pc, init_hw_next				; done

init_hw_generic_keyboard:
	ifn [keyboard_device_id], 0xffff	; already got one?
		set pc, init_hw_next			; can only deal with one right now
	set [keyboard_device_id], i			; store the device ID
	set a, 3							; enable keyboard interrupts
	set b, isr_handle_keyboard			; handler address as the message
	hwi i								; send that
	set pc, init_hw_next				; done

init_hw_generic_clock:
	ifn [clock_device_id], 0xffff	; already got one?
		set pc, init_hw_next		; can only deal with one right now
	set [clock_device_id], i		; store the device ID	
	set a, 0						; set timebase
	set b, 60						; tick at 1Hz
	hwi i							; send that
	set a, 2						; enable clock interrupts
	set b, isr_handle_clock			; handler address as the message
	hwi i							; send that	
	set pc, init_hw_next			; done
		
init_hw_end:
	; -- done initialising devices
  ife [screen_vram], 0  ; do we have a memory-mapped screen?
    sub pc, 1           ; if not, we don't know how to continue.
    
  ; populate screen with init_message
  set i, init_message     ; message data
  set j, [screen_vram]    ; start of VRAM
  set [shellproc_line_vram_start], j  ; tell the shell where it is
  add j, SCREEN_COLUMNS   ; shell will scroll console up on entry, so no point writing anything to top line
1:
  set c, [i]              ; fetch colour
  ife c, 0                ; if it's zero
    b 1f                  ;   we're done
  add i, 1                ; skip over colour
  jsr strcpy              ; copy text
  add i, 1                ; skip over null terminator
  b 1b                    ; go around
1:


  ; can now hand over to shell
  iaq 1                   ; critical section
  set x, shellproc_table  ; shell process table
  set y, [proclist]       ; current process
  jsr dll_splice          ; splice shell process in just before us
  iaq 0                   ; end of critical section

  set pc, Exit            ; release init process memory to system

init_message:
;              0123456789ABCDEF0123456789ABCDEF
  dat 0x2000, "MoonOS 0.1                      ", 0
  dat 0x2000, "Luna City 1985                  ", 0
  dat 0x2000, "                                ", 0
  dat 0x2000, "                                ", 0  
  dat 0x2000, "                                ", 0
  dat 0

	RESERVE_WORDS( 0x20 )	; stack
  
initproc_table:
  dat idleproc_table    ; next
  dat idleproc_table    ; prev
  dat init_start        ; block start
  dat initproc_table    ; no stack
.org initproc_table + kerntable_size

; ------------------
; End of kernel
; Rest of memory is available on boot
; ------------------
kernel_end: 

.org 0 - kerntable_size
freemem_first:
freemem_last:
	dat freelist   		; next
	dat freelist		; prev
	dat kernel_end 		; block start
