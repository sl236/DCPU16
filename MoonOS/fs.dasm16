; ----- Filesystem API table
; ----- for all functions, z points to FS API instance on entry
; ----- all functions may trash any registers; they return 0 in A on success, a nonzero error code on failure.
; ----- all functions block and do not return until the operation completes
; ----- all counts/sizes/offsets are in words (not bytes or sectors)

def fs_fopen 		0x0	; z; a..b: filepath  c: fs_open_mode  on success, returns handle in x
def fs_fread 		0x1	; z; a: handle  b: dest address  c: word count    reads to EOF or C, returns actual word count read in x
def fs_fwrite		0x2	; z; a: handle  b: source address  c: word count  returns word count written in X
def fs_fseek		0x3	; z; a: handle  b: position (low)  c: position(high)  returns actual new position in X. Position is absolute offset from start of file. If greater than EOF, EOF will result.
def fs_ftell		0x4	; z; a: handle  returns current position in b(low), file size in X (low), Y (high)
def fs_fclose		0x5	; z; a: handle
def fs_fflush		0x6	; z; a: handle
def fs_dopendir		0x7	; z; a..b: filename	on success, returns handle in x
def fs_dreaddir		0x8	; z; a: handle			returns next directory entry name in b..c, type in x
def fs_dclosedir	0x9 ; z; a: handle
def fs_stat			0xA	; z; a..b: filepath		on success and if entry exists, returns filesize in X(low), Y(high), file type in B
def fs_unlink		0xB	; z; a..b: filepath
def fs_errstr		0xC	; z; a: error code. Returns pointer to compressed human-readable message for error code.
def fs_umount		0xD	; z
def fs_api_size		0xE

def fs_impl_next	0
def fs_impl_mount	1	; mount takes device id (0..3) in a, returns FS API instance pointer in B and 0 in A on success, or a nonzero error code in A on failure.

def fs_filetype_file	inode_type_file
def fs_filetype_dir		inode_type_dir

def fs_open_mode_r		1
def fs_open_mode_w	 	2
def fs_open_mode_rw 	(fs_open_mode_r|fs_open_mode_w)
def fs_open_mode_trunc 	4
def fs_open_mode_create	8

; ----- Filesystem implementations
def moonfs_fs_api_ptr			0x00
def moonfs_fs_device			0x01
def moonfs_fs_memory_handle		0x02
def moonfs_fs_superblock		0x03
def moonfs_fs_root				0x04
def moonfs_fs_cache0			0x05
def moonfs_fs_cache1			0x06
def moonfs_fs_cache2			0x07
def moonfs_fs_cache3			0x08
def moonfs_fs_refcount			0x09
def moonfs_fs_cache0_sector		0x0A
def moonfs_fs_cache1_sector		0x0B
def moonfs_fs_cache2_sector		0x0C
def moonfs_fs_cache3_sector		0x0D
def moonfs_fs_cache0_refs		0x0E
def moonfs_fs_cache1_refs		0x0F
def moonfs_fs_cache2_refs		0x10
def moonfs_fs_cache3_refs		0x11
def moonfs_fs_cache0_lock		0x12
def moonfs_fs_cache1_lock		0x13
def moonfs_fs_cache2_lock		0x14
def moonfs_fs_cache3_lock		0x15
def moonfs_fs_cache_waiting		0x16
def moonfs_fs_instance_size		0x17

def moonfs_success				0
def moonfs_err_not_implemented	1
def moonfs_err_read				2
def moonfs_err_write			3
def moonfs_err_bad_magic		4
def moonfs_err_fs_unmounted		5
def moonfs_err_not_found		6

def moonfs_handle_inode			0
def moonfs_handle_pos			1
def moonfs_handle_access		2
def moonfs_handle_memblock		3
def moonfs_handle_size			(moonfs_handle_memblock+1)

moonfs_api:
	dat moonfs_fopen_impl
	dat moonfs_fread_impl
	dat moonfs_fwrite_impl
	dat moonfs_fseek_impl
	dat moonfs_ftell_impl
	dat moonfs_fclose_impl
	dat moonfs_fflush_impl
	dat moonfs_dopendir_impl
	dat moonfs_dreaddir_impl
	dat moonfs_dclosedir_impl
	dat moonfs_stat_impl
	dat moonfs_umount_impl
	dat moonfs_errstr

moonfs_mount_impl:
	set push, a						; stash argument
	set z, [a+fdd_mounted_fs]		; currently mounted FS
	set a, [z]						; API instance
	ifn z, 0						; was an FS mounted?
		jsr [a+fs_umount]			; unmount it
	set a, pop						; restore argument
	
	set x, moonfs_fs_instance_size	; FS instance
	set b, [a+fdd_sector_size]
	mul b, 6						; and six sectors' worth of memory (ouch)
	add x, b
	jsr kmalloc
	set b, x						; block handle
	set b, [y+kerntable_block_start]; its start
	
	set [b+moonfs_fs_api_ptr], moonfs_api
	set [b+moonfs_fs_device], a
	set [b+moonfs_fs_memory_handle], x
	set [b+moonfs_fs_refcount], 1
		
	set x, b						; FS instance
	add x, moonfs_fs_instance_size	; start of block memory
	
	set [b+moonfs_fs_cache0_sector], 0xffff
	set [b+moonfs_fs_cache1_sector], 0xffff
	set [b+moonfs_fs_cache2_sector], 0xffff
	set [b+moonfs_fs_cache3_sector], 0
	set [b+moonfs_fs_cache0_refs], 1
	set [b+moonfs_fs_cache1_refs], 1
	set [b+moonfs_fs_cache2_refs], 1
	set [b+moonfs_fs_cache3_refs], 1
	set [b+moonfs_fs_cache0_lock], 1
	set [b+moonfs_fs_cache1_lock], 1
	set [b+moonfs_fs_cache2_lock], 1
	set [b+moonfs_fs_cache3_lock], 1
	
	set [b+moonfs_fs_cache0], x
	add x, [a+fdd_sector_size]
	set [b+moonfs_fs_cache1], x
	add x, [a+fdd_sector_size]
	set [b+moonfs_fs_cache2], x
	add x, [a+fdd_sector_size]
	set [b+moonfs_fs_cache3], x
	add x, [a+fdd_sector_size]
	set [b+moonfs_fs_superblock], x
	add x, [a+fdd_sector_size]
	set [b+moonfs_fs_root], x
	
	set push, b
	
	set c, [b+moonfs_fs_cache3]	; destination, while we still have b around
	set x, [b+moonfs_fs_device]	; target device
	set [x+fdd_mounted_fs], b	; let other processes know we've grabbed it
	set a, 0					; boot sector
	set b, 3					; if it's a moonfs, first three sectors are boot sector, superblock, root inode in that order.
	jsr fdd_read_impl			; try to read that
	set z, pop					; get api ptr back
	sub [z+moonfs_fs_cache0_refs], 1	; cache now available
	sub [z+moonfs_fs_cache0_lock], 1
	sub [z+moonfs_fs_cache1_refs], 1
	sub [z+moonfs_fs_cache1_lock], 1
	sub [z+moonfs_fs_cache2_refs], 1
	sub [z+moonfs_fs_cache2_lock], 1
	sub [z+moonfs_fs_cache3_refs], 1
	sub [z+moonfs_fs_cache3_lock], 1
	ife a, 0					; success?
		b 1f
	set a, moonfs_err_read
	set pc, moonfs_umount_internal
1:
	set x, [b+moonfs_fs_superblock]	; superblock ptr
	ife [x-3], 0x6D6F	; check bootsector magic
	ife [x-2], 0x6F6E
	ife [x-1], 0x6673
		b 1f
	set a, moonfs_err_bad_magic
	set pc, moonfs_umount_internal
1:
	set a, 0	; it's a moonfs, and z is a valid API instance	
	set b, z
	set pc, pop

; -- in: API in Z, sector ID in A, lock flag in B.
;	 out: API in Z, error code in A, memory ptr to filled cache line in B, other regs trashed. May block.
;    if B is nonzero, cache line is returned locked.
;    NB if A is 0, cache line in B will be held until passed back to one of moonfs_discard_sector or moonfs_flush_sector
moonfs_fetch_sector:
	macro moonfs_check_cache_for_fetch( _cacheline )
		ifn [z+moonfs_fs_cache0_sector+_cacheline], a	; is this the sector we're looking for?
			b 1f
		ifn [z+moonfs_fs_cache0_lock+_cacheline], 0		; is it locked?
			set pc, moonfs_cache_wait_for_lock
		set a, 0										; success
		set b, [z+moonfs_fs_cache0+_cacheline]			; ptr to sector
		add [z+moonfs_fs_cache0_refs+_cacheline], 1		; claim a reference
		set pc, pop										; return
	1:
	endm
	moonfs_check_cache_for_fetch( 0 )
	moonfs_check_cache_for_fetch( 1 )
	moonfs_check_cache_for_fetch( 2 )
	moonfs_check_cache_for_fetch( 3 )
	
	; couldn't find a usable sector already in the cache
	; look for a free line
1:
	jsr moonfs_check_mounted
	ifn a, 0
		set pc, pop
	set b, z
	ife [b+moonfs_fs_cache0_refs], 0
		b 2f
	add b, 1	
	ife [b+moonfs_fs_cache0_refs], 0
		b 2f
	add b, 1	
	ife [b+moonfs_fs_cache0_refs], 0
		b 2f
	add b, 1	
	ife [b+moonfs_fs_cache0_refs], 0
		b 2f
	jsr moonfs_cache_wait				; wait for a free line
	set pc, 1b
2:
	set [b+moonfs_fs_cache0_sector], a	; store the cache line info
	add [b+moonfs_fs_cache0_refs], 1
	add [b+moonfs_fs_cache0_lock], 1
	set push, z							; save api and line index to stack
	set push, b
	set c, [b+moonfs_fs_cache0]			; destination in memory
	set x, [z+moonfs_fs_device]			; device ID
	set b, 1							; one sector
	jsr fdd_read_impl					; read it
	set z, pop							; get back api, line index
	set b, pop
	sub [b+moonfs_fs_cache0_lock], 1	; unlock line
	ifn [z+moonfs_fs_cache_waiting], 0	; if processes are waiting on the cache
		jsr moonfs_cache_notify			; let them know
	set b, [b+moonfs_fs_cache0]			; cache line address
	set pc, pop							; return to caller

; -- 
moonfs_cache_wait_for_lock:
	jsr moonfs_cache_wait
	set pc, moonfs_fetch_sector

moonfs_cache_wait:
	set push, z
	set push, a
	set push, 3f
	
	iaq 1
	set x, [proclist]
	set y, [x]
	jsr dll_delete
	set [proclist], y
	ife [z+moonfs_fs_cache_waiting], 0
		set [z+moonfs_fs_cache_waiting], x
	set y, [z+moonfs_fs_cache_waiting]
	jsr dll_splice
	set [x+kerntable_saved_sp], sp
	set x, [proclist]
	set sp, [x+kerntable_saved_sp]
	iaq 0
	set pc, pop

3:
	set a, pop
	set z, pop
	set pc, pop	

; --
moonfs_cache_notify:
	set push, x
	set push, y
	set push, a
	set push, b
	set x, [z+moonfs_fs_cache_waiting]
	set y, [proclist]
	iaq 1
	jsr dll_splice
	iaq 0
	set [z+moonfs_fs_cache_waiting], 0
	set b, pop
	set a, pop
	set y, pop
	set x, pop
	set pc, pop

; -- in: API in Z, memory ptr previously returned by moonfs_claim_sector in B. Cache line is unlocked. Error code in A.
moonfs_unlock_sector:
	set a, [z+moonfs_fs_device]
	set a, [a+fdd_sector_size]
	sub b, [z+moonfs_fs_cache0]
	div b, a
	add b, z
	set a, 0
	sub [b+moonfs_fs_cache0_lock], 1
	ifn [b+moonfs_fs_cache0_lock], 0
		set pc, pop	
	ife [z+moonfs_fs_cache_waiting], 0
		set pc, pop
	jsr moonfs_cache_notify
	set a, 0
	set pc, pop

; -- in: API in Z, memory ptr previously returned by moonfs_claim_sector in B. Cache line is released. Error code in A.
moonfs_discard_sector:
	set a, [z+moonfs_fs_device]
	set a, [a+fdd_sector_size]
	sub b, [z+moonfs_fs_cache0]
	div b, a
	add b, z
	set a, 0
	sub [b+moonfs_fs_cache0_refs], 1
	ifn [b+moonfs_fs_cache0_refs], 0
		set pc, pop	
	ife [z+moonfs_fs_cache_waiting], 0
		set pc, pop
	jsr moonfs_cache_notify
	set a, 0
	set pc, pop
	
; -- in - z; b: ptr to 7 words of packed chars. out: a - offset into data area for start of search. c - data area size
moonfs_namehash_impl:
	set a, [z+moonfs_fs_device]
	set a, [a+fdd_sector_size]
	sub a, inode_header_size
	set c, a
	div a, direntry_size
	set push, a
	set a, [b]
	xor a, [b+1]
	xor a, [b+2]
	xor a, [b+3]
	xor a, [b+4]
	xor a, [b+5]
	xor a, [b+6]
	mod a, pop
	mul a, direntry_size
	set pc, pop

; -- in - z; a: source inode. b: ptr to 7 0-padded words of packed chars. 
; -- out - a: error code. b: (on success) inode index. Other regs trashed.
moonfs_inode_getid_impl:
	set push, b						; stash target name
	set b, 0
	jsr moonfs_fetch_sector			; cache ptr in b				
	set x, b						; x= source inode ptr
	set b, pop						; restore target name
	ifn a, 0						; check for error
		set pc, pop					; bail if we got an error
	jsr moonfs_namehash_impl		; hash the name
	set y, a						; store initial ptr
1:
	ife [a+inode_header_size+direntry_inode], 0	; empty record?
		b 2f				; not found, then
	ife [a+inode_header_size+0], [b+0]
	ife [a+inode_header_size+1], [b+1]
	ife [a+inode_header_size+2], [b+2]
	ife [a+inode_header_size+3], [b+3]
	ife [a+inode_header_size+4], [b+4]
	ife [a+inode_header_size+5], [b+5]
	ife [a+inode_header_size+6], [b+6]
		b 1f							; found it!
	add a, direntry_size				; next dir entry
	mod a, c							; wrap to stay in data area
	ifn a, y							; tried everywhere?
		b 1b							; nope. go around.
2:
	set a, moonfs_err_not_found
	set pc, pop	
1:
	set a, 0
	set b, [a+inode_header_size+direntry_inode]
	set pc, pop
	
; -- z; a: filepath (null-terminated, unpacked).  b: fs_open_mode  on success, returns handle in b. Other registers may be trashed.
moonfs_fopen_impl:
	ifn b, fs_open_mode_r
		set pc, moonfs_not_implemented ; todo
		
	set push, b	; store open mode
	sub sp, 7	; space on stack for packed filename
	set i, sp	; target
	set j, a	; source
	set x, 7	; maximum length
	jsr strnpack_fill	; pack
	
	
	sub pc, 1 ; todo
	
; --
moonfs_fread_impl:
	set pc, moonfs_not_implemented ; todo

; --	
moonfs_fwrite_impl:
	set pc, moonfs_not_implemented ; todo

; --
moonfs_fseek_impl:
	set pc, moonfs_not_implemented ; todo

; --
moonfs_ftell_impl:
	set pc, moonfs_not_implemented ; todo

; --
moonfs_fclose_impl:
	set pc, moonfs_not_implemented ; todo

; --
moonfs_fflush_impl:
	set pc, moonfs_not_implemented ; todo

; --
moonfs_dopendir_impl:
	set pc, moonfs_not_implemented ; todo

; --
moonfs_dreaddir_impl:
	set pc, moonfs_not_implemented ; todo

; --
moonfs_dclosedir_impl:
	set pc, moonfs_not_implemented ; todo

; --
moonfs_stat_impl:
	set pc, moonfs_not_implemented ; todo

; --
moonfs_umount_impl:
	set a, 0
moonfs_umount_internal:
	set b, z
	ifn [b+moonfs_fs_cache0_sector], 0xffff
		jsr moonfs_umount_lock_cache
	add b, 1
	ifn [b+moonfs_fs_cache0_sector], 0xffff
		jsr moonfs_umount_lock_cache
	add b, 1
	ifn [b+moonfs_fs_cache0_sector], 0xffff
		jsr moonfs_umount_lock_cache
	add b, 1
	ifn [b+moonfs_fs_cache0_sector], 0xffff
		jsr moonfs_umount_lock_cache
	
	set a, pop
	set x, [z+moonfs_fs_device]
	set [x+fdd_mounted_fs], 0
	sub [z+moonfs_fs_refcount], 1
	ifn [z+moonfs_fs_refcount], 0
		set pc, pop
	set x, [z+moonfs_fs_memory_handle]
	set pc, kfree

moonfs_umount_lock_cache:
	ife [b+moonfs_fs_cache0_refs], 0
		b 1f
	set [sp], moonfs_umount_internal
	set pc, moonfs_cache_wait		
1:
	set [b+moonfs_fs_cache0_refs], 1
	set [b+moonfs_fs_cache0_lock], 1
	set [b+moonfs_fs_cache0_sector], 0xffff
	set pc, pop

moonfs_check_mounted:
	set a, [z+moonfs_fs_device]
	ifn [a+fdd_mounted_fs], z
		b 1f
	set a, 0
	set pc, pop
1:
	set a, moonfs_err_fs_unmounted
	set pc, pop
	
; --
moonfs_errstr:
	set pc, moonfs_not_implemented ; todo

; --
moonfs_not_implemented:
	set a, moonfs_err_not_implemented
	set pc, pop
	
