; ------------------
; interrupt handlers
; ------------------

def isr_header_magic 0x3457
isr_entry:
	bor a, 0
	ifn [a-1], isr_header_magic		; sanity check: does the message hold the address of an ISR?
	    rfi 0						; nope. Ignore it
	set pc, a						; branch to handler



dat isr_header_magic	; ---- keyboard handler	
isr_handle_keyboard:
	set push, b					; store b and c for interrupted process
	set push, c
	
	set a, 2					; key held?
	set b, 0x91					; CTRL
	hwi [keyboard_device_id]	; ask the keyboard
	set [ctrl_held], c			; store the response
	ifn c, 0					; *is* it held?
		b isr_hk_ctrl			; if so, users don't see our keypresses
	
    set b, [screen_curr_terminal]	; got a foreground terminal?
    ife b, 0						; nope, so can't have a process blocking on it
    	b isr_hk_fastexit
	ife [b+term_waiting_keyproc], 0	; process waiting on keyboard?
		b isr_hk_fastexit			; nope. Bail.
		
	set push, x					; can't trash registers of whatever we interrupted, store them
	set push, y					
	set x, [b+term_waiting_keyproc]	; fetch waiting process
	set [b+term_waiting_keyproc], 0 ; it's not waiting any more
	set y, [proclist]			; active process
	jsr dll_splice				; add the process that was waiting just before it
	set y, pop					; restore registers
	set x, pop
	
isr_hk_fastexit:	
	set c, pop
	set b, pop
	rfi 0						; exit ISR

isr_hk_ctrl:
	set a, 1					; poll key queue
	hwi [keyboard_device_id]	; do that
	ifn c, 0					; got something?
		set [ctrl_keypress], c	; stash it
	b isr_hk_fastexit			; done



dat isr_header_magic	; ---- clock tick handler	
isr_handle_clock:
	set push, ex
	add [clock_time], 1
	add [clock_time+1], ex
	set ex, pop
	rfi 0
