; ------------------
; terminal handling
; ------------------

term_return_popxy:
	set x, pop
	set y, pop
	set pc, pop

; rotate left through VTs, preserving registers
term_rotate_left:
	set push, y
	set push, x
	set x, [screen_curr_terminal]			; current terminal
	ife x, 0								; not got one?
	  set pc, term_return_popxy				; then we're done
	set y, [x+term_block_handle]			; the block handle
	set y, [y+kerntable_prev]				; previous terminal's block handle
	set y, [y+kerntable_block_start]		; its term structure
	ife y, x								; is there only one terminal?
	  set pc, term_return_popxy				; then we're done
	set [screen_curr_terminal], y			; this'll be the new terminal	
	set x, pop
	set y, pop
	set pc, term_map_current				; map it

; rotate right through VTs, preserving registers
term_rotate_right:
	set push, y
	set push, x
	set x, [screen_curr_terminal]			; current terminal
	ife x, 0								; not got one?
	  set pc, term_return_popxy				; then we're done
	set y, [x+term_block_handle]			; the block handle
	set y, [y+kerntable_next]				; previous terminal's block handle
	set y, [y+kerntable_block_start]		; its term structure
	ife y, x								; is there only one terminal?
	  set pc, term_return_popxy				; then we're done
	set [screen_curr_terminal], y			; this'll be the new terminal
	set x, pop
	set y, pop
	set pc, term_map_current				; map it
		
; map the current VT to hardware, preserving registers
term_map_current:
	set push, x
	set push, a
	set push, b
	set x, [screen_curr_terminal]			; current terminal
	set a, LEM1802_MEM_MAP_SCREEN
	set b, [x+term_vram_curr]
	hwi [screen_device_id]
	set a, LEM1802_MEM_MAP_FONT
	set b, [x+term_charmap]
	hwi [screen_device_id]
	set a, LEM1802_MEM_MAP_PALETTE
	set b, [x+term_palette]
	hwi [screen_device_id]
	set a, LEM1802_SET_BORDER_COLOUR
	set b, [x+term_border_colour]
	hwi [screen_device_id]
	set b, pop
	set a, pop
	set x, pop
	set pc, pop

; Release the current process's terminal, trashing registers
; hardware will display another VT or turn off as appropriate if necessary
term_release:
	set x, [proclist]						; current process
	set x, [x+kerntable_block_start]		; its header
	set y, [x+kernheader_terminal_handle]	; its terminal
	ife y, 0								; don't have one?
		set pc, pop							; then we're done
	
	set [x+kernheader_terminal_handle], 0	; won't have one after we're done
	ife y, [screen_curr_terminal]			; is it being displayed?
		jsr term_rotate_left				; not any more...
	set a, LEM1802_MEM_MAP_SCREEN			; prepare to turn it off
	set b, 0
	ifn y, [screen_curr_terminal]			; and if the rotation failed, do so
		b 1f
	
	hwi [screen_device_id]
	set [screen_curr_terminal], 0

1:	
	set x, [y+term_block_handle]			; get the memory block handle
	jsr dll_delete							; remove it from the terminal list
	set pc, free							; release it, then we're done

; Allocate a terminal for the current process. Trashes registers.
; Any existing terminal is released. Then VRAM is allocated.
; The A register is also examined, and charmap and palette are allocated 
; if the appropriate term_alloc_flags are set
; The new terminal is mapped to the screen.
term_alloc:	
	set push, a							; need the argument preserved
	jsr term_release					; release current terminal, if any
	set z, pop							; get flags back
	
	set x, ((SCREEN_ROWS+SCROLL_AMORTISE)*SCREEN_COLUMNS) + term_desc_size	; vram and descriptor
	ifb z, term_alloc_flag_charmap
		add x, 0x100
	ifb z, term_alloc_flag_palette
		add x, 0x10
	jsr malloc							; allocate memory for these
	
	set i, [x+kerntable_block_start]	; new terminal descriptor
	set b, i							; calculate vram start
	add b, term_desc_size
	sti [i], b							; store it
1:
	sti [i], 0							; most terminal descriptor entries start as zero
	ifn i, b
		b 1b
	set i, [x+kerntable_block_start]	; get terminal descriptor handle back
	set [i+term_owner], [proclist]		; fill the entries we can
	set [i+term_vram_start], [i+term_vram_curr]
	set [i+term_block_handle], x
	
	add b, ((SCREEN_ROWS+SCROLL_AMORTISE)*SCREEN_COLUMNS)	; end of VRAM
	set [i+term_vram_end], b			; record that
	ifc z, term_alloc_flag_charmap		; if we got a charmap and/or palette, calculate those addresses
		set pc, 1f						; otherwise skip over the calculations
	set [i+term_charmap], b
	set a, LEM1802_MEM_DUMP_FONT
	hwi [screen_device_id]
	add c, 0x100
1:
	ifc z, term_alloc_flag_palette	
		set pc, 1f
	set a, LEM1802_MEM_DUMP_PALETTE
	hwi [screen_device_id]
	set [i+term_palette], b
1:	
	set y, [screen_curr_terminal]		; current terminal
	ife y, 0							; if we don't have one, skip splicing
		set pc, 1f
	set y, [y+term_block_handle]		; its block handle
	jsr dll_splice						; insert us just before
1:
	set x, [x+kerntable_block_start]	; terminal descriptor
	set [screen_curr_terminal], x		; we become the current terminal	
	set x, [proclist]											; current process
	set x, [x+kerntable_block_start]							; its header
	set [x+kernheader_terminal_handle], [screen_curr_terminal]	; it owns this terminal
	jsr term_clear						; clear VRAM
	jsr term_map_current				; map us
	set x, idleproc_table				; idle process handle
	set pc, taskswitch_to_process		; taskswitch over so it can populate the status line; on resume return to caller

; ---- get current terminal descriptor in x
term_get_term_desc_x:
	set x, [proclist]							; current process
	set x, [x+kerntable_block_start]			; its header	
	set x, [x+kernheader_terminal_handle] 		; its terminal descriptor
	set pc, pop

; ---- scroll one line up; return end of scroll area in i and x
term_scroll_impl:
	jsr term_get_term_desc_x
	set push, x
	set i, [x+term_vram_curr]					; start of current VRAM window
	
	set j, i									; can we amortise the scroll cost by remapping a row down instead?
	add j, SCREEN_ROWS * SCREEN_COLUMNS	
	ife j, [x+term_vram_end]
		b 2f	; we can't
	
	; don't scroll, just take the screen start down a row	
	add i, SCREEN_COLUMNS
	set [x+term_vram_curr], i
	add i, (SCREEN_COLUMNS * (STATUS_ROW-2))
	set x, i	
	b 3f
	
2:	; remap back to start of VRAM	
	set j, i
	add j, SCREEN_COLUMNS               		; next row down
	set i, [x+term_vram_start]					; target is start of whole VRAM area
	set [x+term_vram_curr], i					; which is now the start of the current VRAM window
	set x, i
	add x, (SCREEN_COLUMNS * (STATUS_ROW-2))	; end of scroll area

1:
	sti [i], [j]
	sti [i], [j]
	sti [i], [j]
	sti [i], [j]
	sti [i], [j]
	sti [i], [j]
	sti [i], [j]
	sti [i], [j]
	ifn i, x      ; end of area?
		b 1b        ; no, go around
				
3:
	add x, SCREEN_COLUMNS * 3	; clear rest of screen
	
1:
	sti [i], 0
	sti [i], 0
	sti [i], 0
	sti [i], 0
	ifn i, x
		b 1b
				
	set x, pop	; get terminal handle back
	ife x, [screen_curr_terminal]				; if this is the current terminal
		jsr term_map_current					; update the mapping
	sub i, SCREEN_COLUMNS * 3					; end of scroll area
	set x, i
	set pc, pop

; copy one-word-per-char string in (j..y) to i, orring with c. 
; On exit, i is next screen posn after string; j is next source posn after string. 
; Trashes a.
term_print_u_ijyc_impl:
	ife j, y		; source empty?
		set pc, pop ; skip copy
	set push, c
1:
	set c, [j]	; fetch character
	set a, c	; argh, take a copy
	and a, 0x7f	; so we can mask it
	ife a, 0xA	; newline?
		b 1f	; bail
	bor c, [sp]	; colour the character
	sti [i], c	; write it
	ifn j, y	; reached the end?
		b 1b	; go around
	set c, pop
	set pc, pop	; done	
1:	; hit a newline
	add j, 1	; skip over the newline
	set c, pop
	set pc, pop	; done
	
; zero from i to x
term_memz_ix_impl:
	ife i, x		; there?
		set pc,pop	; done
1:
	sti [i], 0	; clear
	ifn i, x	; end of line?
		b 1b	; loop
	set pc,pop	; done
	
; ---- clear: clears the screen
term_clear:
	set push, i
	set push, j
	set push, x
	jsr term_get_term_desc_x
	ife x, [screen_curr_terminal]				; if this is the current terminal
		jsr term_map_current					; update the mapping
	set [x+term_vram_curr], [x+term_vram_start]	; reset vram start
	set i, [x+term_vram_start]					; start of VRAM
	set x, [x+term_vram_end]					; end of VRAM

1:
	sti [i], 0
	sti [i], 0
	sti [i], 0
	sti [i], 0
	sti [i], 0
	sti [i], 0
	sti [i], 0
	sti [i], 0
	ifn i, x
		b 1b
	set x, pop
	set j, pop
	set i, pop
	set pc, pop

; ---- println: prints string held between x and y inclusive
; ---- using colour in c, on last line before status line; Preserves other registers.
; ---- respects \n character
term_println:
	jsr proc_storestate			; store regs

1:
	jsr term_scroll_impl		; scroll_impl returns bottom row in i, x
	set j, [sp+storedstate_x]	; source string
	set y, [sp+storedstate_y]	; end of source string

	set a, y					; end
	sub a, j					; length
	ifg (SCREEN_COLUMNS+1), a	; fits on one line?
		b 2f
		
	set y, j					; just do one line at a time
	add y, SCREEN_COLUMNS
2:		

	set c, [sp+storedstate_c]	; colour
	jsr term_print_u_ijyc_impl	; returns next screen position after string in i, progress through source in j
	set [sp+storedstate_x], j	; note how much we've done	
	add x, SCREEN_COLUMNS*2		; end of next screen line
	jsr term_memz_ix_impl		; clear to end
	jsr TaskSwitch				; might as well	
	ifl [sp+storedstate_x], [sp+storedstate_y]	; more lines?
		set pc, 1b								; print them
				
	jsr proc_restorestate		; restore regs			
	set pc, pop					; return
