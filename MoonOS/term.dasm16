; ------------------
; terminal handling
; ------------------

term_return_popxy:
	set x, pop
	set y, pop
	set pc, pop

; rotate left through VTs, preserving registers
term_rotate_left:
	set push, y
	set push, x
	set x, [screen_curr_terminal]			; current terminal
	ife x, 0								; not got one?
	  set pc, term_return_popxy				; then we're done
	set y, [x+term_block_handle]			; the block handle
	set y, [y+kerntable_prev]				; previous terminal's block handle
	set y, [y+kerntable_block_start]		; its term structure
	ife y, x								; is there only one terminal?
	  set pc, term_return_popxy				; then we're done
	set [screen_curr_terminal], y			; this'll be the new terminal	
	set x, pop
	set y, pop
	set pc, term_map_current				; map it

; rotate right through VTs, preserving registers
term_rotate_right:
	set push, y
	set push, x
	set x, [screen_curr_terminal]			; current terminal
	ife x, 0								; not got one?
	  set pc, term_return_popxy				; then we're done
	set y, [x+term_block_handle]			; the block handle
	set y, [y+kerntable_next]				; previous terminal's block handle
	set y, [y+kerntable_block_start]		; its term structure
	ife y, x								; is there only one terminal?
	  set pc, term_return_popxy				; then we're done
	set [screen_curr_terminal], y			; this'll be the new terminal
	set x, pop
	set y, pop
	set pc, term_map_current				; map it
		
; map the current VT to hardware, preserving registers
term_map_current:
	set push, x
	set push, a
	set push, b
	set x, [screen_curr_terminal]			; current terminal
	set a, LEM1802_MEM_MAP_SCREEN
	set b, [x+term_vram_curr]
	hwi [screen_device_id]
	set a, LEM1802_MEM_MAP_FONT
	set b, [x+term_charmap]
	hwi [screen_device_id]
	set a, LEM1802_MEM_MAP_PALETTE
	set b, [x+term_palette]
	hwi [screen_device_id]
	set a, LEM1802_SET_BORDER_COLOUR
	set b, [x+term_border_colour]
	hwi [screen_device_id]
	set b, pop
	set a, pop
	set x, pop
	set pc, pop

; Release the current process's terminal, trashing registers
; hardware will display another VT or turn off as appropriate if necessary
term_release:
	set x, [proclist]						; current process
	set x, [x+kerntable_block_start]		; its header
	set y, [x+kernheader_terminal_handle]	; its terminal
	ife y, 0								; don't have one?
		set pc, pop							; then we're done
	
	set [x+kernheader_terminal_handle], 0	; won't have one after we're done
	ife y, [screen_curr_terminal]			; is it being displayed?
		jsr term_rotate_left				; not any more...
	set a, LEM1802_MEM_MAP_SCREEN			; prepare to turn it off
	set b, 0
	ifn y, [screen_curr_terminal]			; and if the rotation failed, do so
		b 1f
	
	hwi [screen_device_id]
	set [screen_curr_terminal], 0

1:	
	set x, [y+term_block_handle]			; get the memory block handle
	jsr dll_delete							; remove it from the terminal list
	set pc, free							; release it, then we're done

; Allocate a terminal for the current process. Trashes registers.
; Any existing terminal is released. Then VRAM is allocated.
; The A register is also examined, and charmap and palette are allocated 
; if the appropriate term_alloc_flags are set
; The new terminal is mapped to the screen.
term_alloc:	
	set push, a							; need the argument preserved
	jsr term_release					; release current terminal, if any
	set z, pop							; get flags back
	
	set x, (SCREEN_ROWS*SCREEN_COLUMNS) + term_desc_size	; vram and descriptor
	ifb z, term_alloc_flag_charmap
		add x, 0x100
	ifb z, term_alloc_flag_palette
		add x, 0x10
	jsr malloc							; allocate memory for these
	
	set i, [x+kerntable_block_start]	; new terminal descriptor
	set b, i							; calculate vram start
	add b, term_desc_size
	sti [i], b							; store it
1:
	sti [i], 0							; most terminal descriptor entries start as zero
	ifn i, b
		b 1b
	set i, [x+kerntable_block_start]	; get terminal descriptor handle back
	set [i+term_owner], [proclist]		; fill the entries we can
	set [i+term_block_handle], x
	set [i+term_cursor_ptr], [i+term_vram_curr]
	
	add b, (SCREEN_ROWS*SCREEN_COLUMNS)	; end of VRAM
	ifc z, term_alloc_flag_charmap		; if we got a charmap and/or palette, calculate those addresses
		set pc, 1f						; otherwise skip over the calculations
	set [i+term_charmap], b
	set a, LEM1802_MEM_DUMP_FONT
	hwi [screen_device_id]
	add c, 0x100
1:
	ifc z, term_alloc_flag_palette	
		set pc, 1f
	set a, LEM1802_MEM_DUMP_PALETTE
	hwi [screen_device_id]
	set [i+term_palette], b
1:	
	set y, [screen_curr_terminal]		; current terminal
	ife y, 0							; if we don't have one, skip splicing
		set pc, 1f
	set y, [y+term_block_handle]		; its block handle
	jsr dll_splice						; insert us just before
1:
	set x, [x+kerntable_block_start]	; terminal descriptor
	set [screen_curr_terminal], x		; we become the current terminal	
	set x, [proclist]											; current process
	set x, [x+kerntable_block_start]							; its header
	set [x+kernheader_terminal_handle], [screen_curr_terminal]	; it owns this terminal
	jsr term_clear						; clear VRAM
	jsr term_map_current				; map us
	set x, idleproc_table				; idle process handle
	set pc, taskswitch_to_process		; taskswitch over so it can populate the status line; on resume return to caller

; ---- get current terminal descriptor in x
term_get_term_desc_x:
	set x, [proclist]							; current process
	set x, [x+kerntable_block_start]			; its header	
	set x, [x+kernheader_terminal_handle] 		; its terminal descriptor
	set pc, pop

; ---- scroll one line up
term_scroll:
	set push, i
	set push, x
	jsr term_get_term_desc_x
	set push, x
	set i, [x+term_vram_curr]					; start of current VRAM window
		
	set j, SCREEN_COLUMNS
	add j, i				               		; next row down
	
	set x, i
	add x, (SCREEN_COLUMNS * (STATUS_ROW-2))	; end of scroll area

1:
	sti [i], [j]
	sti [i], [j]
	sti [i], [j]
	sti [i], [j]
	sti [i], [j]
	sti [i], [j]
	sti [i], [j]
	sti [i], [j]
	ifn i, x      ; end of area?
		b 1b        ; no, go around
	set x, pop
	set [x+term_cursor_ptr], i					; new data can be written here
	set x, pop
	set i, pop
	set pc, pop

; copy one-word-per-char string in (j..y) to i, orring with c. 
; On exit, i is next screen posn after string; j is next source posn after string. 
; a is last character processed
term_print_u_ijyc_impl:
	ife j, y		; source empty?
		set pc, pop ; skip copy
	set push, c
1:
	set c, [j]	; fetch character
	set a, c	; argh, take a copy
	and a, 0x7f	; so we can mask it
	ife a, 0xA	; newline?
		b 1f	; bail
	bor c, [sp]	; colour the character
	sti [i], c	; write it
	ifn j, y	; reached the end?
		b 1b	; go around
	set c, pop
	set pc, pop	; done	
1:	; hit a newline
	add j, 1	; skip over the newline
	set c, pop
	set pc, pop	; done
	
; zero from i to x
term_memz_ix_impl:
	ife i, x		; there?
		set pc,pop	; done
1:
	sti [i], 0	; clear
	ifn i, x	; end of line?
		b 1b	; loop
	set pc,pop	; done
	
; ---- clear: clears the screen
term_clear:
	set push, i
	set push, j
	set push, x
	jsr term_get_term_desc_x
	set i, [x+term_vram_curr]					; start of VRAM
	set [x+term_cursor_ptr], i					; cursor will end up at start of VRAM
	set x, i
	add x, STATUS_ROW * SCREEN_COLUMNS			; not including status row

1:
	sti [i], 0
	sti [i], 0
	sti [i], 0
	sti [i], 0
	sti [i], 0
	sti [i], 0
	sti [i], 0
	sti [i], 0
	ifn i, x
		b 1b
	set x, pop
	set j, pop
	set i, pop
	set pc, pop

; ---- print: prints string held between x and y inclusive
; ---- using colour in c. Preserves other registers.
; ---- respects \n character
term_print:
	ife x, y					; empty string?
		set pc, pop				; do nothing
		
	set push, x
	jsr proc_storestate			; store regs

1:
	jsr term_get_term_desc_x			; terminal descriptor
	set a, [x+term_vram_curr]
	add a, (STATUS_ROW*SCREEN_COLUMNS)	; end of printable area
	
	set i, [x+term_cursor_ptr]
	sub a, i							; available space
	
	set j, [sp+storedstate_x]
	set y, [sp+storedstate_y]
	sub y, j							; length of string we got asked to print
		
	ifl a, y							; if that's longer than available space
		set y, a						; only print that much
	
	add y, [sp+storedstate_x]			; end of what we can safely print
	
	set c, [sp+storedstate_c]	; colour
	jsr term_print_u_ijyc_impl	; print
	set [x+term_cursor_ptr], i	; new cursor position
	set [sp+storedstate_x], j	; note how much we've done
	ifn a, 0xa					; hit a newline?
		b 2f					; nope

	set a, i					; cursor
	add a, (SCREEN_COLUMNS-1)	; align to screen row, rounding up
	and a, ~(SCREEN_COLUMNS-1)
	ife i, a		; there?
		b 2f
3:
	sti [i], 0	; clear
	ifn i, a	; end of line?
		b 3b	; loop
	
	jsr term_scroll
2:	
	set a, [x+term_vram_curr]
	add a, (STATUS_ROW*SCREEN_COLUMNS)	; end of printable area
	ife [x+term_cursor_ptr], a
		jsr term_scroll
	
	jsr TaskSwitch				; might as well	
	ifl [sp+storedstate_x], [sp+storedstate_y]	; more lines?
		set pc, 1b								; print them
				
	jsr proc_restorestate		; restore regs			
	set x, pop
	set pc, pop					; return

1:  dat 0xa
; ---- println: as print, but appends a newline
term_println:
	jsr term_print
	set push, x
	set push, y
	set x, 1b
	set y, term_println
	jsr term_print
	set y, pop
	set x, pop
	set pc, pop