; ------------------
; boot process
; ------------------
initproc_header:
	dat 0						; terminal handle
	dat 0						; message handler
	dat shellproc_identifier	; we'll be handing over to the shell when we're done, so use its identifier
	dat 0						; entrypoint

.org initproc_header + kernheader_size

init:  
  set [1], exit_impl			; the jump at location 0 needs to go to the Exit implementation
  set sp, initproc_table		; at boot, the stack pointer was not set up for us
  ias isr_entry					; can now handle interrupts
  
	; -- Free memory size calculation
	set x, freelist
1:
	set a, x
	sub a, [x+kerntable_block_start]
	add [freemem_size], a
	set x, [x]
	ifn x, freelist
		b 1b
  
	; -- Device enumeration
  set i, 0						; running device count
  hwn j							; total number of devices
   
init_hw:
	ife i, j					; enumerated everything?
		set pc, init_hw_end		; bail
	
	hwq i						; fetch device params into a+b, c, x+y
	
	; LEM1802 Low Energy Monitor - http://dcpu.com/highnerd/rc_1/lem1802.txt
	ife b, 0x7349
	ife a, 0xf615
		set pc, init_hw_lem1802

	; Generic Keyboard (compatible) - http://dcpu.com/highnerd/rc_1/keyboard.txt
	ife b, 0x30cf
	ife a, 0x7406
		set pc, init_hw_generic_keyboard

	; Generic Clock (compatible) - http://dcpu.com/highnerd/rc_1/clock.txt
	ife b, 0x12d0
	ife a, 0xb402
		set pc, init_hw_generic_clock

init_hw_next:
	add i, 1							; next device ID
	set pc, init_hw						; go around

init_hw_lem1802:
	ifn [screen_device_id], 0xffff		; already got one?
		set pc, init_hw_next			; can only deal with one right now
	set [screen_device_id], i			; store the device ID	
	set pc, init_hw_next				; done

init_hw_generic_keyboard:
	ifn [keyboard_device_id], 0xffff	; already got one?
		set pc, init_hw_next			; can only deal with one right now
	set [keyboard_device_id], i			; store the device ID
	set a, 3							; enable keyboard interrupts
	set b, isr_handle_keyboard			; handler address as the message
	hwi i								; send that
	set pc, init_hw_next				; done

init_hw_generic_clock:
	ifn [clock_device_id], 0xffff	; already got one?
		set pc, init_hw_next		; can only deal with one right now
	set [clock_device_id], i		; store the device ID	
	set a, 0						; set timebase
	set b, CLOCK_TICK_RATE			; 
	hwi i							; send that
	set a, 2						; enable clock interrupts
	set b, isr_handle_clock			; handler address as the message
	hwi i							; send that	
	set pc, init_hw_next			; done
		
init_hw_end:
	; -- done initialising devices
  ife [screen_device_id], 0xffff  	; do we have a screen?
    sub pc, 1           			; if not, we don't know how to continue.
    
  ; allocate a terminal; no special requirements
  set a, 0
  jsr term_alloc
    
  ; populate screen with init_message
  set i, init_message     			; message data
  set j, [screen_curr_terminal]   	; terminal descriptor
  set j, [j+term_vram]				; VRAM start
  set [shellproc_line_vram_start], j  ; tell the shell where it is
  add j, SCREEN_COLUMNS   ; shell will scroll console up on entry, so no point writing anything to top line
1:
  set c, [i]              ; fetch colour
  ife c, 0                ; if it's zero
    b 1f                  ;   we're done
  add i, 1                ; skip over colour
  jsr strcpy              ; copy text
  add i, 1                ; skip over null terminator
  b 1b                    ; go around
1:
  
  ; hand ownership of our terminal over to the shell
  set x, [initproc_header+kernheader_terminal_handle]
  set [shellproc_header+kernheader_terminal_handle], x
  set [initproc_header+kernheader_terminal_handle], 0
  set [x+term_owner], shellproc_table

  ; insert shell into process list
  iaq 1                   ; critical section
  set x, shellproc_table  ; shell process table
  set y, [proclist]       ; current process
  jsr dll_splice          ; splice shell process in just before us
  iaq 0                   ; end of critical section

  set pc, Exit            ; release init process memory to system

init_message:
;              0123456789ABCDEF0123456789ABCDEF
  dat 0x2000, "MoonOS 0.1                      ", 0
  dat 0x2000, "Luna City 1985                  ", 0
  dat 0

  	RESERVE_WORDS( 0x20 )	; stack
  
initproc_table:
  dat idleproc_table    ; next
  dat idleproc_table    ; prev
  dat init_start        ; block start
  dat initproc_table    ; no stack
.org initproc_table + kerntable_size
