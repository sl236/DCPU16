; ------------------
; boot process
; ------------------
initproc_header:
	dat 0						; terminal handle
	dat 0						; message handler
	dat initproc_identifier		; identifier

.org initproc_header + kernheader_size

initproc_identifier:
	dat "MoonOS init", 0

init:  
	set [1], exit_impl			; the jump at location 0 needs to go to the Exit implementation
	set sp, initproc_table		; at boot, the stack pointer was not set up for us
	ias isr_entry					; can now handle interrupts
  
	; -- Free memory size calculation
	set x, freelist
1:
	set a, x
	sub a, [x+kerntable_block_start]
	add [freemem_size], a
	set x, [x]
	ifn x, freelist
		b 1b
  
	; -- Device enumeration
  set i, 0						; running device count
  hwn j							; total number of devices
   
init_hw:
	ife i, j					; enumerated everything?
		set pc, init_hw_end		; bail
	
	hwq i						; fetch device params into a+b, c, x+y
	
	; LEM1802 Low Energy Monitor - http://dcpu.com/highnerd/rc_1/lem1802.txt
	ife b, 0x7349
	ife a, 0xf615
		set pc, init_hw_lem1802

	; Generic Keyboard (compatible) - http://dcpu.com/highnerd/rc_1/keyboard.txt
	ife b, 0x30cf
	ife a, 0x7406
		set pc, init_hw_generic_keyboard

	; Generic Clock (compatible) - http://dcpu.com/highnerd/rc_1/clock.txt
	ife b, 0x12d0
	ife a, 0xb402
		set pc, init_hw_generic_clock

init_hw_next:
	add i, 1							; next device ID
	set pc, init_hw						; go around

init_hw_lem1802:
	ifn [screen_device_id], 0xffff		; already got one?
		set pc, init_hw_next			; can only deal with one right now
	set [screen_device_id], i			; store the device ID	
	set pc, init_hw_next				; done

init_hw_generic_keyboard:
	ifn [keyboard_device_id], 0xffff	; already got one?
		set pc, init_hw_next			; can only deal with one right now
	set [keyboard_device_id], i			; store the device ID
	set a, 3							; enable keyboard interrupts
	set b, isr_handle_keyboard			; handler address as the message
	hwi i								; send that
	set pc, init_hw_next				; done

init_hw_generic_clock:
	ifn [clock_device_id], 0xffff	; already got one?
		set pc, init_hw_next		; can only deal with one right now
	set [clock_device_id], i		; store the device ID	
	set a, 0						; set timebase
	set b, CLOCK_TICK_RATE			; 
	hwi i							; send that
	set a, 2						; enable clock interrupts
	set b, isr_handle_clock			; handler address as the message
	hwi i							; send that	
	set pc, init_hw_next			; done
		
init_hw_end:
	; -- done initialising devices
  ife [screen_device_id], 0xffff  	; do we have a screen?
    sub pc, 1           			; if not, we don't know how to continue.
  
  jsr spawn_new_shell			; fork a shell
  jsr TaskSwitch
;  jsr spawn_new_shell			; fork another shell
;  jsr TaskSwitch
;  jsr term_rotate_left			; rotate terminals left
;  jsr TaskSwitch
  set pc, Exit            		; exit, releasing this memory to the system   

  RESERVE_WORDS( 0x20 )	; stack
  
initproc_table:
  dat idleproc_table    ; next
  dat idleproc_table    ; prev
  dat init_start        ; block start
  dat initproc_table    ; no stack
.org initproc_table + kerntable_size
