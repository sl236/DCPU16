; ----- Exit
; ----- Exits current process, releasing its memory and removing it from the task list
exit_impl:
  jsr term_release	  ; if we owned a terminal, free it
  iaq 1				  ; critical section
  set x, [proclist]		; [proclist] is current process (to be deleted)
  set z, [x]			; next process
  set [proclist], z		; will be current when we're done
  jsr dll_delete		; remove from the process list
  iaq 0				  ; end critical section
  
  jsr free			  ; release process memory
	
	; done! taskswitch to next process
  set a,    [proclist]					; next process table
  set sp,   [a + kerntable_saved_sp]	; fetch its sp
  set pc,   pop						; return there

; ----- Fork
; ----- Allocate X words of memory for a new process.
; ----- New process will have at least X words available between start of its process space and SP, but may have more.
; ----- Old process's stack will be copied to new process space.
; ----- Execution will resume in old process space for both processes, however the new process' SP will point to the new stack

fork_impl:
  add X, kernheader_size		; caller shouldn't need to take our headers into account
  set A, [proclist]       		; current process' table
  sub A, SP               		; area required for current stack
  add A, 0x20					; ensure some minimal space for ISRs, kernel calls etc
  ifg A, X                		; if the result is more than caller asked for
    set X, A              		; use that instead

  jsr malloc			  		; allocate process memory
  
  	; clear process header
  	set j, [x+kerntable_block_start]
  	set y, j
  	add y, kernheader_size
1:
	sti [j], 0
	ifn j, y
		b 1b
		  
  ; now we need to copy the stack over  
  set i, [proclist]   ; old stack starts at the process table
  set j, x            ; new stack starts at the new process table
  
1:
  std [j], [i]		  ; copy and decrement
  ifn i, SP           ; if we've not copied the whole stack
    b 1b              ; go around
  set [j], [i]		  ; copy last word

  set [x+kerntable_saved_sp], j ; store new process SP
  
  set Y, [proclist]   ; current process table address
  iaq 1				  ; critical section
  jsr dll_splice		; add the new process to the process list
  iaq 0				  ; end critical section
  set pc, pop         ; we're done

; ----- WaitForRPCCall
; ----- This process is suspended until another process sends it an RPC call.
; ----- On entry, if A is nonzero, it is assumed to be a process handle for a previously suspended process; 
; ----- that process is woken.
; ----- On return, A contains the calling process handle; 
; ----- B and C are as they were in the calling process; 
; ----- all other register content is undefined.
rpcwait_impl:
	set z, a						; preserve input	
	set x, [proclist]				; current process
	set [x+kerntable_saved_sp], sp	; current stack pointer
	
	iaq 1							; critical section
	set push, [x]					; next process in active list
	jsr dll_delete					; remove from active list
	set y, [rpchandlerlist]			; rpc handler list
	jsr dll_splice					; add self there	
	set y, pop						; next process

	ife z, 0						; if we weren't told to wake up a process
		b 1f						; skip waking one up
	set x, z						; the process we were asked to wake up
	jsr dll_splice					; splice it into the active list
	set y, x						; and make it the one we switch to
1:

	set [proclist], y				; new process now active
	set sp, [y+kerntable_saved_sp]	; next process's sp
	iaq 0							; end of critical section
	set pc, pop						; done here	
	
; ----- PerformRPCCall
; ----- A points to a null-terminated string. 
; ----- The set of processes currently in a WaitForRPCCall is searched for a matching identifier.
; ----- If one is found, that process is called (see WaitForRPCCall) with the contents of the B and C registers,
; ----- and the current process is suspended until the target reenters the RPC call wait state. 
; ----- On return, A is the process handle for the process that was called, or 0 if no match was found.
rpccall_impl:
	set push, a							; save target name ptr on stack
	set x, [rpchandlerlist]				; get first handler
	ife x, rpchandlerlist				; out of handlers?
		b rpccall_fail					; can't call any
1:
	set i, [sp]							; fetch target name ptr
	set j, [x+kerntable_block_start]	; candidate handler process table
	set j, [j+kernheader_identifier]	; its identifier
	set a, 0							; assume no match
	ifn j, 0							; if there's an identifier,
		jsr strcmp						; compare it
	ifn a, 0							; if there was a match
		b rpccall_match					; deal with it
			
	set x, [x]							; next handler
	ifn x, rpchandlerlist				; out of handlers?
		b 1b							; go around
			
rpccall_fail:
	set a, pop							; don't need target name on stack any more
	set a, 0							; report failure to caller
	set pc, pop							; return
	
rpccall_match:							; found a matching handler, it is in X
	set [sp], x							; replace target name ptr with handler
	set push, b							; stash first argument (dll_* trash b)
	iaq 1								; critical section
	set x, [proclist]					; current process handle
	set y, [x]							; next active process
	jsr dll_delete						; remove it from active process list
	set z, x							; stash it in z
	set x, [sp+1]						; target process handle
	jsr dll_delete						; remove from available RPC handlers
	jsr dll_splice						; insert immediately before next active process
	set b, pop							; restore B
	set a, z							; source process handle in A	
	set push, rpccall_reentry			; we come back here
	set [z+kerntable_saved_sp], sp		; store our sp
	set [proclist], x					; target now live
	set sp, [x+kerntable_saved_sp]		; fetch target process sp
	iaq 0								; end critical section
	set pc, pop							; reenter target process

rpccall_reentry:
	set a, pop							; process that was called
	set pc, pop							; return to caller

def storedstate_a	8
def storedstate_b	7
def storedstate_c	6
def storedstate_x	5
def storedstate_y	4
def storedstate_z	3
def storedstate_i	2
def storedstate_j	1
def storedstate_ex	0

; stores all regs and EX to stack
proc_storestate:
	xor [sp], a		; swap return address and a
	xor a, [sp]
	xor [sp], a
	set push, b
	set push, c
	set push, x
	set push, y
	set push, z
	set push, i
	set push, j
	set push, ex
	set push, a						; store return address
	set a, [sp+storedstate_a+1]		; restore correct a value
	set pc, pop		

; restores all regs and EX from stack content created by proc_storestate
proc_restorestate:
	set a, pop		; return addr
	set ex, pop		; restore other regs
	set j, pop
	set i, pop
	set z, pop
	set y, pop
	set x, pop
	set c, pop
	set b, pop
	xor [sp], a		; swap return addr and a
	xor a, [sp]
	xor [sp], a
	set pc, pop