; ------------------
; shell
; ------------------
def SCREEN_ROWS     12
def SCREEN_COLUMNS  32
def SHELL_ROWS      10
def SHELL_COLOUR    0x2000
def CURSOR_MASK     0x2200

shellproc_header:
	dat 0						; terminal handle
	dat 0						; message handler
	dat shellproc_identifier	;
	dat 0						; entrypoint

.org shellproc_header + kernheader_size

shellproc_identifier: "Shell", 0

; ---- data area

shellproc_line_buffer_memory:
  RESERVE_WORDS( SCREEN_COLUMNS )
shellproc_line_buffer_memory_end:
  dat 0	; space for NULL

shellproc_line_cursor:
  dat 0
shellproc_line_end:
  dat 0

shellproc_line_vram_start:
  dat 0  
shellproc_line_vram_curr:
  dat 0

shellproc_scroll:
  set i, [shellproc_line_vram_start]  ; VRAM start
  set j, i
  add j, SCREEN_COLUMNS               ; next row down
  set x, i
  add x, (SCREEN_COLUMNS * (SHELL_ROWS-1))		; end of scroll area

1:
  sti [i], [j]  ; copy to row above
  ifn i, x      ; end of area?
    b 1b        ; no, go around
  set pc, pop	; return

; ---- entrypoint
shellproc_entry:
  jsr shellproc_scroll	; make a new line
      
  set [shellproc_line_vram_curr], [shellproc_line_vram_start]		; start of VRAM
  add [shellproc_line_vram_curr], (SCREEN_COLUMNS * (SHELL_ROWS-1))	; line entry will be here  
  set [shellproc_line_cursor], shellproc_line_buffer_memory		; cursor posn in buffer
  set [shellproc_line_end], shellproc_line_buffer_memory+1		; end of used area
  set [shellproc_line_buffer_memory], 0							; null terminator	

shellproc_update_screen:        
  set i, shellproc_line_buffer_memory       ; update display: from buffer memory
  set j, [shellproc_line_vram_curr]         ; to VRAM...
  set x, j									; (also find end of line
  add x, SCREEN_COLUMNS						;  while we have the value around)
  set c, SHELL_COLOUR                       ; ...using the shell colour
  jsr strcpy                                ; and copy

1:
  sti [j], 0								; clear rest of line
  ifn j, x									; at end of line?
    b 1b									; go around

shellproc_readline_loop:
	set a, [shellproc_line_vram_curr]       ; calc cursor posn
	add a, [shellproc_line_cursor]			; it's (vram + cursor ptr) - start ptr
	sub a, shellproc_line_buffer_memory
	set [cursor_data], a					; store that
	set [cursor_data+1], CURSOR_MASK		; enable cursor
	set [cursor_data+2], 0					; display immediately
	
	jsr TaskSwitch						; give others a chance to run
	
	set B, 1							; use blocking form
	jsr ReadChar						; fetch next char
	
	set z, [shellproc_line_cursor]		; address of insertion point in buffer
	set z, [z]							; character at insertion point
	ifn z, 0							; if it's not null
		bor z, SHELL_COLOUR					; use shell colour
	set x, [cursor_data]				; current cursor address
	set [x], z							; update VRAM, hiding cursor if present	
	set [cursor_data+1], 0				; ensure it's not made visible partway through editing
  
	ifl C, 0x1e                 ; editing char?
		set pc, shellproc_handle_edit   ; handle that
	ifg c, 0x83							; above set of known codes?
		set pc, shellproc_readline_loop	; ignore
	ifg C, 0x7f											; arrow?
		set pc, [c + shellproc_arrow_handlers - 0x80]	; handle that

	; insert regular character
	set i, [shellproc_line_end]               ; current end of line
	ife i, shellproc_line_buffer_memory_end   ; out of memory?
		set pc, shellproc_readline_loop       ; drop the keypress

	set x, [shellproc_line_cursor]            ; current cursor pos
	set j, i                                  ; line end
	add i, 1                                  ; we're adding a character
1:
	std [i], [j]                              ; shuffle characters up
	ifn j, x                                  ; at cursor position?
		b 1b                                    ; no, keep shuffling
	set [i], [j]                              ; character under cursor as well

	set [x], c                                ; new character goes here  
	add [shellproc_line_cursor], 1            ; cursor moves on one character
	add [shellproc_line_end], 1               ; as does end of line
	set pc, shellproc_update_screen			  ; update screen and loop
    
shellproc_handle_edit:
	ifl c, 0x10								; below set of known codes?
		set pc, shellproc_readline_loop			; ignore
	ifg c, 0x13								; above set of known codes?
		set pc, shellproc_readline_loop			; ignore
	set pc, [c + shellproc_edit_handlers - 0x10]	; use as index into branch table
  
shellproc_edit_handlers:
    dat shellproc_handle_backspace
    dat shellproc_handle_return
    dat shellproc_handle_insert
    dat shellproc_handle_delete

shellproc_handle_backspace:
    set x, [shellproc_line_end]
    set i, [shellproc_line_cursor]
    ife i, shellproc_line_buffer_memory
		set pc, shellproc_readline_loop		; can't backspace past start of buffer!
    set j, i
    sub i, 1
    set [shellproc_line_cursor], i
1:
    sti [i], [j]
    ifn i, x
        b 1b
    set [i], 0
    sub [shellproc_line_end], 1
    set pc, shellproc_update_screen
            
shellproc_handle_insert:    
    set pc, shellproc_readline_loop ; todo
    
shellproc_handle_delete:    
    set x, [shellproc_line_end]
    set i, [shellproc_line_cursor]
    set j, i
    add j, 1
    ife j, x
		set pc, shellproc_readline_loop		; no characters to delete!
1:
    sti [i], [j]
    ifn i, x
        b 1b
    set [i], 0
    sub [shellproc_line_end], 1
    set pc, shellproc_update_screen
  
shellproc_arrow_handlers:
	dat shellproc_handle_up, shellproc_handle_down, shellproc_handle_left, shellproc_handle_right
		
shellproc_handle_up:
	set [shellproc_line_cursor], shellproc_line_buffer_memory
	set pc, shellproc_readline_loop
	
shellproc_handle_down:
	set [shellproc_line_cursor], [shellproc_line_end]
	sub [shellproc_line_cursor], 1
	set pc, shellproc_readline_loop
	
shellproc_handle_left:
	ifn [shellproc_line_cursor], shellproc_line_buffer_memory
		sub [shellproc_line_cursor], 1
	set pc, shellproc_readline_loop
	
shellproc_handle_right:
	add [shellproc_line_cursor], 1
	ife [shellproc_line_cursor], [shellproc_line_end]
		sub [shellproc_line_cursor], 1		
	set pc, shellproc_readline_loop
  	
shellproc_handle_return:
	; todo
	set pc, shellproc_entry				; reenter shell, triggering scroll and buffer reset

; ------------------------------------------------------------------------

term_return_popxy:
		set x, pop
		set y, pop
		set pc, pop

; rotate left through VTs, preserving registers
term_rotate_left:
	set push, y
	set push, x
	set x, [screen_curr_terminal]			; current terminal
	ife x, 0								; not got one?
	  set pc, term_return_popxy				; then we're done
	set y, [x+term_block_handle]			; the block handle
	set y, [y+kerntable_prev]				; previous terminal's block handle
	set y, [y+kerntable_block_start]		; its term structure
	ife y, x								; is there only one terminal?
	  set pc, term_return_popxy				; then we're done
	set [screen_curr_terminal], y			; this'll be the new terminal	
	set x, pop
	set y, pop
	set pc, term_map_current				; map it

; rotate right through VTs, preserving registers
term_rotate_right:
	set push, y
	set push, x
	set x, [screen_curr_terminal]			; current terminal
	ife x, 0								; not got one?
	  set pc, term_return_popxy				; then we're done
	set y, [x+term_block_handle]			; the block handle
	set y, [y+kerntable_next]				; previous terminal's block handle
	set y, [y+kerntable_block_start]		; its term structure
	ife y, x								; is there only one terminal?
	  set pc, term_return_popxy				; then we're done
	set [screen_curr_terminal], y			; this'll be the new terminal
	set x, pop
	set y, pop
	set pc, term_map_current				; map it
		
; map the current VT to hardware, preserving registers
term_map_current:
	set push, x
	set push, a
	set push, b
	set x, [screen_curr_terminal]			; current terminal
	set a, LEM1802_MEM_MAP_SCREEN
	set b, [x+term_vram]
	hwi [screen_device_id]
	set a, LEM1802_MEM_MAP_FONT
	set b, [x+term_charmap]
	hwi [screen_device_id]
	set a, LEM1802_MEM_MAP_PALETTE
	set b, [x+term_palette]
	hwi [screen_device_id]
	set a, LEM1802_SET_BORDER_COLOUR
	set b, [x+term_border_colour]
	hwi [screen_device_id]
	set b, pop
	set a, pop
	set x, pop
	set pc, pop

; Release the current process's terminal, trashing registers
; hardware will display another VT or turn off as appropriate if necessary
term_release:
	set x, [proclist]						; current process
	set x, [x+kerntable_block_start]		; its header
	set y, [x+kernheader_terminal_handle]	; its terminal
	ife y, 0								; don't have one?
		set pc, pop							; then we're done
	
	set [x+kernheader_terminal_handle], 0	; won't have one after we're done
	ife y, [screen_curr_terminal]			; is it being displayed?
		jsr term_rotate_left				; not any more...
	set a, LEM1802_MEM_MAP_SCREEN			; prepare to turn it off
	set b, 0
	ife y, [screen_curr_terminal]			; and if the rotation failed, do so
		hwi [screen_device_id]
	
	set x, [y+term_block_handle]			; get the memory block handle
	set pc, free							; release it, then we're done

; Allocate a terminal for the current process. Trashes registers.
; Any existing terminal is released. Then VRAM is allocated.
; The A register is also examined, and charmap and palette are allocated 
; if the appropriate term_alloc_flags are set
; The new terminal is mapped to the screen.
term_alloc:	
	set push, a							; need the argument preserved
	jsr term_release					; release current terminal, if any
	set z, pop							; get flags back
	
	set x, 0x180 + term_desc_size		; vram and descriptor
	ifb z, term_alloc_flag_charmap
		add x, 0x100
	ifb z, term_alloc_flag_palette
		add x, 0x10
	jsr malloc							; allocate memory for these
	
	set i, [x+kerntable_block_start]	; new terminal descriptor
	set [i+term_block_handle], x		; its block handle
	set b, i							; vram starts at i+term_desc_size
	add b, term_desc_size
	sti [i], b	; vram					; write terminal descriptor: vram pointer, zero for the rest
	sti [i], 0	; charmap
	sti [i], 0  ; palette
	sti [i], 0  ; border colour
	add b, 0x180
	ifc z, term_alloc_flag_charmap		; if we got a charmap and/or palette, calculate those addresses
		set pc, 1f						; otherwise skip over the calculations
	set [i-3], b
	set a, LEM1802_MEM_DUMP_FONT
	hwi [screen_device_id]
	add c, 0x100
1:
	ifc z, term_alloc_flag_palette	
		set pc, 1f
	set a, LEM1802_MEM_DUMP_PALETTE
	hwi [screen_device_id]
	set [i-2], b
1:	
	set y, [screen_curr_terminal]		; current terminal
	ife y, 0							; if we don't have one, skip splicing
		set pc, 1f
	set y, [y+kerntable_block_start]	; its block handle
	jsr dll_splice						; insert us just before
1:
	set x, [x+kerntable_block_start]	; terminal descriptor
	set [screen_curr_terminal], x		; we become the current terminal
	set x, [x+term_vram]				; vram ptr
	set i, x							; also in i
	add x, 0x180						; end of vram
1:
	sti [i], 0							; clear VRAM
	sti [i], 0
	sti [i], 0
	sti [i], 0
	ifn i, x
		b 1b
		
	jsr term_map_current				; map us
	set x, idleproc_table				; idle process handle
	set pc, taskswitch_to_process		; taskswitch over so it can populate the status line; on resume return to caller
	
; ------------------------------------------------------------------------
  		  		
	RESERVE_WORDS( 0x20 )	; stack space
shellproc_sp:
	dat shellproc_entry
	
shellproc_table:
	dat shellproc_table		; next
	dat shellproc_table		; prev
	dat shellproc_header	; block start
	dat shellproc_sp		; sp
.org shellproc_table + kerntable_size
