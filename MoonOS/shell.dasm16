; ------------------
; shell
; ------------------
def SCREEN_ROWS     12
def SCREEN_COLUMNS  32
def SHELL_ROWS      10
def SHELL_COLOUR    0x9000
def CURSOR_MASK     0x9900

shell_identifier:
	dat "shell", 0

shell_greeting:
	dat "MoonOS 0.1 -- Luna City 1985", 0
  
shell_prompt_char: 
	dat (0x24 | SHELL_COLOUR)

; ---- println: prints string held between x and y inclusive
; ---- using colour in c, on last line before status line; Preserves other registers.
shellproc_println:
	set push, i
	set push, j
	set push, x
	set push, y
	set push, c

	; in the shell we have these values available, but let's reacalculate them so this is reusable
	set i, [proclist]							; current process
	set i, [i+kerntable_block_start]			; its header	
	set i, [i+kernheader_terminal_handle] 		; its terminal descriptor
	set i, [i+term_vram]						; start of VRAM
  
	set j, i
	add j, SCREEN_COLUMNS               		; next row down
	set x, i
	add x, (SCREEN_COLUMNS * (SHELL_ROWS-2))	; end of scroll area

1:
	sti [i], [j]  ; copy to row above
	sti [i], [j]
	sti [i], [j]
	sti [i], [j]
	sti [i], [j]
	sti [i], [j]
	sti [i], [j]
	sti [i], [j]
	ifn i, x      ; end of area?
		b 1b        ; no, go around
  
	set i, x		; bottom row
	set j, [sp+2]	; source string
	set y, [sp+1]	; end of source string
	ife j, y		; source empty?
		b 2f		; skip copy
1:
	set c, [j]	; fetch character
	bor c, [sp]	; colour it
	sti [i], c	; write it
	ifn j, y	; reached the end?
		b 1b	; go around
2:

	add x, SCREEN_COLUMNS*2	; end of next screen line
	ife i, x	; there?
		b 2f	; skip
1:
	sti [i], 0	; clear screen
	ifn i, x	; end of line?
		b 1b	; loop
2:

	set c, pop
	set y, pop
	set x, pop
	set j, pop
	set i, pop
	set pc, pop	

; ---- entrypoint
shellproc_entry:
	set x, [proclist]								; our process handle
	set x, [x+kerntable_block_start]				; our header block
	set [x+kernheader_identifier], shell_identifier	; set the process identifier
	
	; allocate a terminal for this shell
	set a, 0			; no particular requirements
	jsr term_alloc

	; populate screen
	set i, shell_greeting    					; message data
	set j, [proclist]							; current process
	set j, [j+kerntable_block_start]			; its header	
	set j, [j+kernheader_terminal_handle] 		; its terminal descriptor
	set j, [j+term_vram]						; VRAM start
	set x, j									; grab a copy
	add x, (SCREEN_COLUMNS * (SHELL_ROWS-1))	; end of usable area
	set c, 0x2000								; colour
	jsr strcpy             						; copy text
1:
	sti [j], 0	; clear screen
	ifn j, x	; end of line?
		b 1b	; loop
												
												; input is displayed on row above status line
	set x, [proclist]							; current process
	set x, [x+kerntable_block_start]			; its header	
	set x, [x+kernheader_terminal_handle] 		; its terminal descriptor
	set x, [x+term_vram]						; start of VRAM
	add x, (SCREEN_COLUMNS * (SHELL_ROWS-1))	; line entry will always be here

												; locate our line buffer immediately after the process header
	set y, [proclist]							; current process
	set y, [y+kerntable_block_start]			; its header
	add y, kernheader_size						; the header's size is the start of the line buffer

	set push, x									; store those
	set push, y	
	def shell_input_line_vram 	1
	def shell_input_line_buffer 0

; ---- shell now initialised; this is the main loop
shellproc_mainloop: 
	set x, [sp+shell_input_line_vram]			; address of input line in VRAM
	set [x], [shell_prompt_char]				; prompt
	add x, 1
  
	set y, [sp+shell_input_line_buffer]			; start of line buffer
	set z, y									; also end of used area
	set i, y									; initial cursor posn
	set j, y									; calculate end of usable area
	add j, ((SCREEN_COLUMNS-1)-1)				; last usable word (allowing for prompt character)
		  
	jsr term_readline		; get a line of input
	
	; y..z is result	
	set x, y			; need that in x..y
	set y, z
	set c, 0x7000		; turn it grey, print and scroll up
	jsr shellproc_println

	; null terminate the whole string
	set [y], 0

	set z, shellproc_verb_list		; built-in verbs
	jsr shellproc_findverb			; check 'em
	ifn z, 0						; found one?
		set pc, shellproc_mainloop	; then we're done

	; no match found
	set x, shellproc_no_verb_match_message
	set y, shellproc_no_verb_match_message_len ; see below
	set c, 0x4000
	jsr shellproc_println
	set pc, shellproc_mainloop
	
; ---- check verb list in z against string in x..y
; ---- list has entries of the form next, handler, null-terminated-string
; ---- calls matching handler. on return, z is 1 if one was found, 0 otherwise
shellproc_findverb:
	; find matching verb
1:
	set z, [z]			; next verb
	ife z, 0			; out of verbs?
		set pc, pop		; bail
		
	set i, z			; verb data
	add i, 2			; string is two words in
	set j, x			; what the user typed
	jsr strcmp			; compare those
	ife a, 0			; not a match?
		b 1b			; go around
	jsr [z+1]			; call handler
	set z, 1			; signal success	
	set pc, pop			; return
	
	
shellproc_no_verb_match_message:		dat "command not found"	
shellproc_no_verb_match_message_len:	dat shellproc_no_verb_match_message_len - shellproc_no_verb_match_message

hello_message:		dat "hello world"
hello_message_len:	dat hello_message_len - hello_message

; ---- builtins
shellproc_verb_list:
	dat 1f	

; -- freelist
1:  dat 1f, 2f, "freelist", 0
2:  set z, freelist
	
	set x, 4f
	set y, 4f + 32
	set c, 0x7000
	jsr shellproc_println
	
	set x, [sp+shell_input_line_buffer+2]
			
3:	
	set c, 0
	set b, x
	set a, z
	jsr format_hex
	set [b+4], ':'
	set [b+5], 0x20	
	add b, 6
	
	set a, [z+kerntable_next]
	jsr format_hex
	set [b+4], 0x20
	add b, 5
	
	set a, [z+kerntable_prev]
	jsr format_hex
	set [b+4], 0x20
	set [b+5], 0x20
	add b, 6
	
	set a, z
	sub a, [z+kerntable_block_start]	
	jsr format_hex
	set [b+4], 0x20
	add b, 5
	
	set a, [z+kerntable_block_start]
	jsr format_hex
	set [b+4], 0x20
	add b, 5

	set a, z
	add a, kerntable_size
	jsr format_hex
	set [b+4], 0x20
	add b, 5
			
	set y, b
	set c, 0x7000
	jsr shellproc_println
	set z, [z]
	ifn z, freelist
		set pc, 3b
	set pc, pop		

		;0123456789abcdef0123456789abcdef
4:	dat "block next prev  size start eob ";

; -- exit
1:  dat 1f, 2f, "exit", 0
2:  set pc, Exit

; -- hello
1:  dat 0, 2f, "hello", 0
2:	set x, hello_message
	set y, hello_message_len
	set c, 0x2C80
	jsr shellproc_println
	set pc, pop