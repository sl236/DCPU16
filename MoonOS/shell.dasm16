; ------------------
; shell
; ------------------
def SCREEN_ROWS     12
def SCREEN_COLUMNS  32
def SHELL_ROWS      10
def SHELL_COLOUR    0x2000
def CURSOR_MASK     0x2200

shell_identifier:
  dat "shell", 0

shell_greeting:
  dat "MoonOS 0.1 -- Luna City 1985", 0

shellproc_scroll:
  set i, [proclist]							; current process
  set i, [i+kerntable_block_start]			; its header	
  set i, [i+kernheader_terminal_handle] 	; its terminal descriptor
  set i, [i+term_vram]						; start of VRAM
  set j, i
  add j, SCREEN_COLUMNS               		; next row down
  set x, i
  add x, (SCREEN_COLUMNS * (SHELL_ROWS-1))		; end of scroll area

1:
  sti [i], [j]  ; copy to row above
  sti [i], [j]
  sti [i], [j]
  sti [i], [j]
  sti [i], [j]
  sti [i], [j]
  sti [i], [j]
  sti [i], [j]
  ifn i, x      ; end of area?
    b 1b        ; no, go around
  set pc, pop	; return

; ---- entrypoint
shellproc_entry:
	set x, [proclist]								; our process handle
	set x, [x+kerntable_block_start]				; our header block
	set [x+kernheader_identifier], shell_identifier	; set the process identifier
	
	; allocate a terminal for this shell
	set a, 0			; no particular requirements
	jsr term_alloc

	; populate screen
	set i, shell_greeting    			; message data
	set j, [proclist]						; current process
	set j, [j+kerntable_block_start]		; its header	
	set j, [j+kernheader_terminal_handle] 	; its terminal descriptor
	set j, [j+term_vram]				; VRAM start
	set x, j							; grab a copy
	add x, (SCREEN_COLUMNS * (SHELL_ROWS-1))	; end of usable area
	add j, SCREEN_COLUMNS   			; main loop scrolls console up so no point writing anything to top line
	set c, 0x2000						; colour
	jsr strcpy             				; copy text
shellproc_clear_j_to_x:
	sti [j], 0						; clear rest of screen
	ifn j, x
		b shellproc_clear_j_to_x
  
shellproc_mainloop: 
	jsr shellproc_scroll						; make a new line
  
	set x, [proclist]							; current process
	set x, [x+kerntable_block_start]			; its header	
	set x, [x+kernheader_terminal_handle] 		; its terminal descriptor
	set x, [x+term_vram]						; start of VRAM
	add x, (SCREEN_COLUMNS * (SHELL_ROWS-1))	; line entry will be here  
  
	; locate our line buffer immediately after the process header
	set y, [proclist]							; current process
	set y, [y+kerntable_block_start]			; its header
	add y, kernheader_size						; the header's size is the start of the line buffer
	set z, y									; also end of used area
	set i, y									; initial cursor posn
	set j, y									; calculate end of usable area
	add j, (SCREEN_COLUMNS-1)					; last usable word
  
	jsr term_readline		; get a line of input
	
	set [z], 0	; z = EOL; null terminate
	; y now points to the null-terminated result
	set i, y
	set j, x
	set C, 0x7000
	jsr strcpy
	add x, SCREEN_COLUMNS
	ifn j, x
		set pc, shellproc_clear_j_to_x	
	set pc, shellproc_mainloop