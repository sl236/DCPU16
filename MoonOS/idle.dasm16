; ------------------
; idle process
; ------------------
idleproc_header:
	dat 0						; terminal handle
	dat 0						; message handler
	dat 0						; identifier
	dat 0						; entrypoint

	.org idleproc_header + kernheader_size
	
idleproc_entry:
	set push, idleproc_entry		; reschedule our entrypoint
	
	set a, [ctrl_keypress]			; check for ctrl+key combo
	ife a, 0						; got one?
		set pc, 1f					; nope; skip to next section
	set [ctrl_keypress], 0			; picked it up
	
	set x, ich_table				; first handler block
	jsr ich_find_handler			; go find something to handle the keypress
	
1:
	ife [screen_curr_terminal], 0	; if we don't have a screen
		set pc, TaskSwitch			; nothing more to do here
	
	set A, [clock_time]				; blink cursor: get the time
	set B, A						; copy it
	and B, CURSOR_BLINK_TIME_MASK	; mask with blink rate mask
	set C, [cursor_data]			; grab cursor pointer
	ifn B, [cursor_data+2]			; if time has changed since last blink
		xor [C], [cursor_data+1]	; blink the cursor
	set [cursor_data+2], B			; update blink time
	
	; update status line
	set A, [clock_time+1]			; top word of clock
	set B, idleproc_statusline		; start of status line
	set C, 0						; no colour yet, we add that later
	jsr format_hex					; 
	set A, [clock_time]				; bottom word of clock
	add B, 5						; skip the colon
	jsr format_hex					;
	set I, idleproc_statusline		; from start of status
    set j, [screen_curr_terminal]
   	set j, [j+kernheader_terminal_handle]	; to start of vram
	add J, 32*STATUS_ROW			; plus the status row offset
	set C, 0x2000					; orring in a colour
	ifn [ctrl_held], 0				; which is different if CTRL is being held
		xor C, 0x2B00				;
	jsr strcpy						; copy
	
	set pc, TaskSwitch				; done
		
ich_find_handler:	; -- loop through control key combo handler blocks, branch to first matching handler or just return if none match
	ife x, 0				; hit the end?
		set pc, pop			; no handler found	
	ifl a, [x]				; smaller than first character?
		b 1f				; can't handle it
	ifg a, [x+1]			; larger than last character?
		b 1f				; can't handle that either
	sub a, [x]				; index into branch table
	add a, x				; handler block start
	set pc, [a+3]			; branch table is three words in		
1:	
	set x, [x+2]			; next block
	b ich_find_handler		; loop round
	
	; first, last, next, branch table
ich_table:
	dat 0x82, 0x83, 0, term_rotate_left, term_rotate_right
	
idleproc_statusline:
	;	 0123456789ABCDEF0123456789ABCDEF
	dat	"0123:4567 ----------------------", 0
		
	RESERVE_WORDS( 0x20 )	; stack space
	
idleproc_sp:
	dat idleproc_entry
  
idleproc_table:
	dat initproc_table		; next
	dat initproc_table		; prev
	dat idleproc_header		; block start
	dat idleproc_sp			; sp
.org idleproc_table + kerntable_size
