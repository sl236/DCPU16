; ------------------
; idle process
; ------------------
idleproc_header:
	dat 0						; terminal handle
	dat 0						; message handler
	dat 0						; identifier
	dat 0						; entrypoint

	.org idleproc_header + kernheader_size
	
idleproc_entry:
	set push, idleproc_entry		; reschedule our entrypoint
	
	set a, [ctrl_keypress]			; check for ctrl+key combo
	ife a, 0						; got one?
		b 1f						; nope; skip to next section
	set [ctrl_keypress], 0			; picked it up
	
	set x, ich_table				; first handler block
	jsr ich_find_handler			; go find something to handle the keypress
	
1:
	set i, [screen_curr_terminal]	; terminal handle
	ife i, 0						; if we don't have a terminal
		set pc, TaskSwitch			; nothing more to do here
	
	set A, [clock_time]				; blink cursor: get the time
	set B, A						; copy it
	and B, CURSOR_BLINK_TIME_MASK	; mask with blink rate mask
	set C, [i+term_cursor_ptr]		; grab cursor pointer
	ifn B, [i+term_cursor_tick]		; if time has changed since last blink
		xor [C], [i+term_cursor_mask]	; blink the cursor
	set [i+term_cursor_tick], B		; update blink time
	
	; update status line
	set A, [clock_time+1]			; top word of clock
	set B, idleproc_statusline		; start of status line
	set C, 0						; no colour yet, we add that later
	jsr format_hex					; 
	set A, [clock_time]				; bottom word of clock
	add B, 5						; skip the colon
	jsr format_hex					;
	set A, [freemem_size]			; free memory size
	add B, 5						; skip the space
	jsr format_hex					;
			
	set j, idleproc_statusline + 0x10
	set b, idleproc_statusline + 0x20
	set i, [i+term_owner]			; current terminal's owning process
	set i, [i+kerntable_block_start]; its header
	set i, [i+kernheader_identifier]; identifier
1:
	ife [i], 0
		b 2f
	sti [j], [i]
	ifn j, b
		b 1b
2:
	sti [j], ' '
	ifn j, b
		b 2b
	
	set i, idleproc_statusline		; from start of status
    set j, [screen_curr_terminal]
   	set j, [j+kernheader_terminal_handle]	; to start of vram
	add J, 32*STATUS_ROW			; plus the status row offset
	set C, 0x2000					; orring in a colour
	ifn [ctrl_held], 0				; which is different if CTRL is being held
		xor C, 0x2B00				;
	jsr strcpy						; copy
	
	set pc, TaskSwitch				; done
		
ich_find_handler:	; -- loop through control key combo handler blocks, branch to first matching handler or just return if none match
	ife x, 0				; hit the end?
		set pc, pop			; no handler found	
	ifl a, [x]				; smaller than first character?
		b 1f				; can't handle it
	ifg a, [x+1]			; larger than last character?
		b 1f				; can't handle that either
	sub a, [x]				; index into branch table
	add a, x				; handler block start
	set pc, [a+3]			; branch table is three words in		
1:	
	set x, [x+2]			; next block
	b ich_find_handler		; loop round
	
	; first, last, next, branch table
ich_table:
	dat 0x82, 0x83, 1f, term_rotate_left, term_rotate_right
1:	dat 'n', 'n', 0, spawn_new_shell

spawn_new_shell:
	set x, SCREEN_COLUMNS + 0x20 + kernheader_size	; line buffer, decent stack and the process header
  	set push, [proclist]			; push current process handle
  	jsr Fork						; create a process
  	ifn [proclist], pop				; are we the original process?    
  		set pc, shellproc_entry		; the child gets the shell
  	set pc, pop						; the parent returns
	

idleproc_statusline:
	;	 0123456789ABCDEF0123456789ABCDEF
	dat	"0123:4567 0000 |                ", 0
		
	RESERVE_WORDS( 0x20 )	; stack space
	
idleproc_sp:
	dat idleproc_entry
  
idleproc_table:
	dat initproc_table		; next
	dat initproc_table		; prev
	dat idleproc_header		; block start
	dat idleproc_sp			; sp
.org idleproc_table + kerntable_size
