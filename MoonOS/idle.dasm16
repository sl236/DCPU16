; ------------------
; idle process
; ------------------
idleproc_entry:
	set push, idleproc_entry		; reschedule our entrypoint
	
	set a, [ctrl_key]				; check for ctrl+key combo
	ifn a, 0						; got one?
		set pc, 1f					; nope; skip to next section
	set [ctrl_key], 0				; picked it up	
	
1:
	ife [screen_vram], 0			; if we don't have a screen
		set pc, TaskSwitch			; nothing more to do here
	
	set A, [clock_time]				; blink cursor: get the time
	set B, A						; copy it
	and B, CURSOR_BLINK_TIME_MASK	; mask with blink rate mask
	set C, [cursor_data]			; grab cursor pointer
	ifn B, [cursor_data+2]			; if time has changed since last blink
		xor [C], [cursor_data+1]	; blink the cursor
	set [cursor_data+2], B			; update blink time
	
	; update status line
	set A, [clock_time+1]
	set B, idleproc_statusline
	set C, 0
	jsr format_hex
	set A, [clock_time]
	add B, 5
	jsr format_hex
	set I, idleproc_statusline
	set J, [screen_vram]
	add J, 32*STATUS_ROW
	set C, 0x2000
	ifn [ctrl_held], 0
		xor C, 0x2B00
	jsr strcpy
	
	set pc, TaskSwitch			; done
	
idleproc_statusline:
	;	 0123456789ABCDEF0123456789ABCDEF
	dat	"0123:4567 ----------------------", 0
		
	RESERVE_WORDS( 0x20 )	; stack space
	
idleproc_sp:
	dat idleproc_entry
  
idleproc_table:
	dat initproc_table		; next
	dat initproc_table		; prev
	dat idleproc_entry		; block start
	dat idleproc_sp			  ; sp
.org idleproc_table + kerntable_size
